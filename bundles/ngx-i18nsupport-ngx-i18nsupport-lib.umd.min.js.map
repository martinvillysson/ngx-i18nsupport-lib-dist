{"version":3,"sources":["../../../projects/ngx-i18nsupport-lib/src/lib/ngx-i18nsupport-lib.module.ts","../../../projects/ngx-i18nsupport-lib/src/api/constants.ts","../../../node_modules/tslib/tslib.es6.js","../../../projects/ngx-i18nsupport-lib/src/impl/dom-utilities.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xml-serializer.ts","../../../projects/ngx-i18nsupport-lib/src/impl/abstract-translation-messages-file.ts","../../../projects/ngx-i18nsupport-lib/src/impl/abstract-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-text.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-placeholder.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-start-tag.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-end-tag.ts","../../../projects/ngx-i18nsupport-lib/src/impl/icu-message-tokenizer.ts","../../../projects/ngx-i18nsupport-lib/src/impl/icu-message.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-icu-message.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-icu-message-ref.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-part-empty-tag.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message.ts","../../../projects/ngx-i18nsupport-lib/src/impl/parsed-message-tokenizer.ts","../../../projects/ngx-i18nsupport-lib/src/impl/abstract-message-parser.ts","../../../projects/ngx-i18nsupport-lib/src/impl/tag-mapping.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff-message-parser.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff-file.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xmb-message-parser.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xmb-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xmb-file.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff2-message-parser.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff2-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xliff2-file.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xtb-trans-unit.ts","../../../projects/ngx-i18nsupport-lib/src/impl/xtb-file.ts","../../../projects/ngx-i18nsupport-lib/src/api/translation-messages-file-factory.ts"],"names":["NgxI18nsupportLibModule","imports","FORMAT_XLIFF12","FORMAT_XLIFF20","FORMAT_XMB","FORMAT_XTB","FILETYPE_XLIFF12","FILETYPE_XLIFF20","STATE_NEW","STATE_TRANSLATED","STATE_FINAL","NORMALIZATION_FORMAT_NGXTRANSLATE","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","this","constructor","create","__read","o","n","m","Symbol","iterator","r","e","i","ar","next","done","push","value","error","__spread","arguments","length","concat","ParsedMessagePartType","DOMUtilities","getFirstElementByTagName","element","tagName","matchingElements","getElementsByTagName","item","getElementByTagNameAndId","id","node","getAttribute","getElementFollowingSibling","nextSibling","nodeType","ELEMENT_NODE","getElementPrecedingSibling","previousSibling","getXMLContent","result","XMLSerializer","serializeToString","nodeName","reStartMsg","RegExp","replace","reEndMsg","getPCDATA","childNodes","child","TEXT_NODE","CDATA_SECTION_NODE","nodeValue","replaceContentWithXMLContent","pcdata","firstChild","removeChild","newChildren","DOMParser","parseFromString","j","newChild","appendChild","ownerDocument","importNode","getPreviousElementSibling","createFollowingSibling","elementNameToCreate","newElement","createElement","insertAfter","parentNode","insertBefore","XmlSerializer","document","options","buf","visibleNamespaces","refNode","documentElement","prefix","uri","namespaceURI","lookupPrefix","namespace","indentString","containsOnlyWhiteSpace","Error","doSerializeToString","join","indentLevel","partOfMixedContent","elementNode","attrs","attributes","len","elementHasMixedContent","isMixedContentElement","outputIndented","attr","localName","needNamespaceDefine","ns","hasComplexContent","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","ATTRIBUTE_NODE","attrNode","name","_xmlEncoder","textNode","beautify","data","cdatasectionNode","COMMENT_NODE","commentNode","DOCUMENT_TYPE_NODE","documenttypeNode","pubid","publicId","sysid","systemId","PROCESSING_INSTRUCTION_NODE","piNode","target","ENTITY_REFERENCE_NODE","c","charCodeAt","outputParts","_i","indentationString","apply","indent","mixedContentElements","find","tag","text","charAt","AbstractTranslationMessagesFile","transUnits","_warnings","parseContent","xmlString","path","encoding","optionalMaster","_filename","_encoding","_parsedDocument","_parsedOptionalMasterDocument","xmlContent","_fileEndsWithEOL","endsWith","lazyInitializeTransUnits","isNullOrUndefined","initializeTransUnits","countNumbers","_this","_numberOfTransUnitsWithMissingId","_numberOfUntranslatedTransUnits","_numberOfReviewedTransUnits","forEachTransUnit","tu","state","targetState","warnings","numberOfTransUnits","numberOfUntranslatedTransUnits","numberOfReviewedTransUnits","numberOfTransUnitsWithMissingId","callback","forEach","transUnitWithId","optionalMasterTransUnitWithId","optionalMasterTransUnits","setNewTransUnitTargetPraefix","targetPraefix","getNewTransUnitTargetPraefix","setNewTransUnitTargetSuffix","targetSuffix","getNewTransUnitTargetSuffix","removeTransUnitWithId","tuNode","getElementById","filter","filename","editedContent","beautifyOutput","elementsWithMixedContent","AbstractTransUnit","_element","_id","_translationMessagesFile","defineProperty","translationMessagesFile","supportsSetSourceContent","sourceContentNormalized","_sourceContentNormalized","createSourceContentNormalized","nativeState","nativeTargetState","mapNativeStateToState","setTargetState","newState","setNativeTargetState","mapStateToNativeState","supportsSetSourceReferences","supportsSetDescriptionAndMeaning","checkNotes","newNotes","errorInFromNote","note","from","asXmlElement","translate","translation","translationNative","isString","asNativeString","translateNative","isICUMessage","message","messageParser","isICUMessageStart","ParsedMessagePart","type","ParsedMessagePartText","_super","TEXT","asDisplayString","format","ParsedMessagePartPlaceholder","index","disp","PLACEHOLDER","_index","_disp","ParsedMessagePartStartTag","tagname","idcounter","START_TAG","_tagname","_idcounter","toString","idCounter","ParsedMessagePartEndTag","END_TAG","CURLY_BRACE_OPEN","CURLY_BRACE_CLOSE","COMMA","PLURAL","SELECT","STATE_NORMAL","STATE_IN_MESSAGE","ICUMessageTokenizer","getLexer","lexer","Tokenizr.default","plaintext","openedCurlyBracesInTextCounter","before","ctx","match","rule","containsNonWhiteSpace","accept","ignore","finish","pop","char","test","tokenize","normalizedMessage","input","tokens","token","peek","MessageCategory","_category","_message","getCategory","getMessageNormalized","ICUMessage","_parser","isPluralMessage","_isPluralMessage","_categories","addCategory","category","varname","choiceString","isSelectMessage","getCategories","translatedCategories","Set","translatedMessage","translationForCategory","add","parseNormalizedString","keys","categoryName","has","checkValidPluralCategory","allowedKeywords","key","ParsedMessagePartICUMessage","icuMessageText","ICU_MESSAGE","parseICUMessage","looksLikeICUMessage","displayFormat","getICUMessage","_messageText","_tokenizer","expectNext","trim","parseNativeSubMessage","tokentype","createNormalizedMessageFromXMLString","ParsedMessagePartICUMessageRef","ICU_MESSAGE_REF","ParsedMessagePartEmptyTag","EMPTY_TAG","ParsedMessage","parser","sourceMessage","_parts","getParser","normalizedString","translateICUMessage","icuTranslation","icuMessage","translatedICUMessage","translateNativeString","nativeString","map","part","_xmlRepresentation","validate","hasErrors","errors","checkPlaceholderAdded","placeholderAdded","checkICUMessageRefRemoved","icuMessageRefRemoved","checkICUMessageRefAdded","icuMessageRefAdded","validateWarnings","w","hasWarnings","checkPlaceholderRemoved","placeholderRemoved","checkTagRemoved","tagRemoved","checkTagAdded","tagAdded","containsICUMessageRef","findIndex","suspiciousIndexes","sourcePlaceholders_1","allPlaceholders","allSuspiciousIndexes_1","first_1","sourcePlaceholders","myPlaceholders_1","allSuspiciousIndexes_2","first_2","sourceICURefs_1","allICUMessageRefs","allSuspiciousIndexes_3","first_3","sourceICURefs","myICURefs_1","allSuspiciousIndexes_4","first_4","parts","getPlaceholderDisp","placeHolder","phPart","getICUMessageRefDisp","icuMessageRefPart","refPart","suspiciousTags","sourceTags_1","allTags","allSuspiciousTags_1","first_5","sourceTags","myTags_1","allSuspiciousTags_2","first_6","setXmlRepresentation","xmlRepresentation","addText","addPlaceholder","addStartTag","addEndTag","openTag","calculateOpenTagName","addEmptyTag","addICUMessageRef","addICUMessage","openTags","ParsedMesageTokenizer","idcount","parseInt","reset","AbstractMessageParser","createNormalizedMessageFromXML","xmlElement","addPartsOfNodeToMessage","includeSelf","processChildren","textContent","processStartElement","getICUMessageText","isICU","console","log","children","processEndElement","createXmlRepresentation","icuMessageString","parseIdCountFromName","exec","num","rootElem","addXmlRepresentationToRoot","createXmlRepresentationOfTextPart","createTextNode","TAG_TO_PLACEHOLDER_NAMES","A","B","BR","EM","H1","H2","H3","H4","H5","H6","HR","I","LI","LINK","OL","P","Q","S","SMALL","SUB","SUP","TBODY","TD","TFOOT","TH","THEAD","TR","TT","U","UL","VOID_TAGS","TagMapping","getStartTagPlaceholderName","upperTag","toUpperCase","counterString","getCloseTagPlaceholderName","getEmptyTagPlaceholderName","getCtypeForTag","toLowerCase","getTagnameFromStartTagPlaceholderName","placeholderName","startsWith","stripCounter","substring","ph_1","matchKey","getTagnameFromCloseTagPlaceholderName","ph_2","isEmptyTagPlaceholderName","ph","indexOf","getTagnameFromEmptyTagPlaceholderName","re","XliffMessageParser","tagMapping","parsePlaceholderIndexFromId","parseICUMessageRefIndexFromId","normalizedTagName","indexString","Number","createXmlRepresentationOfStartTagPart","createXmlRepresentationOfEndTagPart","createXmlRepresentationOfEmptyTagPart","createXmlRepresentationOfPlaceholderPart","createXmlRepresentationOfICUMessageRefPart","xElem","idAttrib","ctypeAttrib","equivTextAttr","setAttribute","XliffTransUnit","sourceContent","sourceElement","setSourceContent","newContent","source","targetContent","targetElement","targetContentNormalized","sourceReferences","sourceElements","sourceRefs","elem","contextElements","sourcefile","linenumber","contextElem","setSourceReferences","removeAllSourceReferences","ref","contextGroup","contextSource","contextLine","toBeRemoved","description","noteElem","findNoteElementWithFromAttribute","setDescription","createNoteElementWithFromAttribute","removeNoteElementWithFromAttribute","attrValue","noteElements","findAllAdditionalNoteElements","fromAttribute","fromAttrValue","content","noteElement","removeAllAdditionalNoteElements","meaning","setMeaning","notes","supportsSetNotes","setNotes","cloneWithSourceAsTarget","isDefaultLang","copyContent","targetFile","clone","cloneNode","useSourceAsTarget","sourceString","newTargetString","XliffFile","initializeFromContent","xliffList","version","i18nFormat","fileType","transUnitsInFile","transunit","transUnitsInOptionalMasterFile","sourceLanguage","fileElem","setSourceLanguage","language","targetLanguage","setTargetLanguage","importNewTransUnit","foreignTransUnit","importAfterElement","newTu","bodyElement","inserted","isAfterElementPartOfFile","undefined","firstUnitElement","refUnitElement","createTranslationFileForLang","lang","translationFile","transUnit","unit","tranUnit","XmbMessageParser","parsePlaceholderIndexFromName","parseTagnameFromPhElement","emptyTagName","parseICUMessageIndexFromName","messageText","reSource","phElement","exElement","createXmlRepresentationOfPart","phElem","nameAttrib","exElem","XmbTransUnit","parseSourceAndPos","sourceAndPos","lastIndexOf","parseLineNumber","lineNumberString","msgContent","insertPosition","XmbFile","_translationMessageFileFactory","msg","guessLanguageFromFilename","split","createFileFromFileContent","Xliff2MessageParser","isInterpolation","isEmptyTag","equiv","embeddedTagName","tagNameFromPCElement","pcNode","dispStart","stack","newTagElem","closeTagName","emptyTagElem","pcElem","equivStart","equivEnd","dispEnd","getTypeForTag","equivAttrib","Xliff2TransUnit","segmentElement","notesElement","findNoteElementWithCategoryAttribute","createNoteElementWithCategoryAttribute","removeNoteElementWithCategoryAttribute","removeNotesElementIfEmpty","segment","Xliff2File","xliffElem","fileElement","XtbTransUnit","_sourceTransUnitFromMaster","XtbFile","_masterFile","numberInMaster","myNumber","masterUnit","translationbundleElem","newMasterTu","translationElement","firstTranslationElement","TranslationMessagesFileFactory","fromFileContent","fromUnknownFormatFileContent","createFileFromUnknownFormatFileContent","formatCandidates","formatCandidate"],"mappings":"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","sourcesContent":["import { NgModule } from '@angular/core';\r\n\r\n@NgModule({\r\n  imports: [\r\n  ],\r\n  declarations: [],\r\n  exports: []\r\n})\r\nexport class NgxI18nsupportLibModule { }\r\n","/**\r\n * Created by roobm on 08.05.2017.\r\n * Some constant values used in the API.\r\n */\r\n\r\n/**\r\n * supported file formats\r\n */\r\nexport const FORMAT_XLIFF12 = 'xlf';\r\nexport const FORMAT_XLIFF20 = 'xlf2';\r\nexport const FORMAT_XMB = 'xmb';\r\nexport const FORMAT_XTB = 'xtb';\r\n\r\n/**\r\n * File types\r\n * (returned by fileType() method)\r\n */\r\nexport const FILETYPE_XLIFF12 = 'XLIFF 1.2';\r\nexport const FILETYPE_XLIFF20 = 'XLIFF 2.0';\r\nexport const FILETYPE_XMB = 'XMB';\r\nexport const FILETYPE_XTB = 'XTB';\r\n\r\n/**\r\n * abstract state value.\r\n * There are only 3 supported state values.\r\n */\r\n\r\n/**\r\n * State NEW.\r\n * Signals an untranslated unit.\r\n */\r\nexport const STATE_NEW = 'new';\r\n/**\r\n * State TRANSLATED.\r\n * Signals a translated unit, that is not reviewed until now.\r\n */\r\nexport const STATE_TRANSLATED = 'translated';\r\n/**\r\n * State FINAL.\r\n * Signals a translated unit, that is reviewed and ready for use.\r\n */\r\nexport const STATE_FINAL = 'final';\r\n\r\n/**\r\n * Normalizaton message formats.\r\n */\r\n\r\n/**\r\n * Default format, contains placeholders, html markup.\r\n */\r\nexport const NORMALIZATION_FORMAT_DEFAULT = 'default';\r\n\r\n/**\r\n * Format for usage in ngxtranslate messages.\r\n * Placeholder are in the form {{n}}, no html markup.\r\n */\r\nexport const NORMALIZATION_FORMAT_NGXTRANSLATE = 'ngxtranslate';\r\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {DOMParser, XMLSerializer} from 'xmldom';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * Some Tool functions for XML Handling.\r\n */\r\n\r\nexport class DOMUtilities {\r\n\r\n    /**\r\n     * return the first subelement with the given tag.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getFirstElementByTagName(element: Element | Document, tagName: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            return matchingElements.item(0);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * return an element with the given tag and id attribute.\r\n     * @param element element\r\n     * @param tagName tagName\r\n     * @param id id\r\n     * @return subelement or null, if not existing.\r\n     */\r\n    public static getElementByTagNameAndId(element: Element | Document, tagName: string, id: string): Element {\r\n        const matchingElements = element.getElementsByTagName(tagName);\r\n        if (matchingElements && matchingElements.length > 0) {\r\n            for (let i = 0; i < matchingElements.length; i++) {\r\n                const node: Element = matchingElements.item(i);\r\n                if (node.getAttribute('id') === id) {\r\n                    return node;\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get next sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementFollowingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.nextSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.nextSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get previous sibling, that is an element.\r\n     * @param element element\r\n     */\r\n    public static getElementPrecedingSibling(element: Element): Element {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let e = element.previousSibling;\r\n        while (e) {\r\n            if (e.nodeType === e.ELEMENT_NODE) {\r\n                return <Element> e;\r\n            }\r\n            e = e.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * return content of element as string, including all markup.\r\n     * @param element element\r\n     * @return content of element as string, including all markup.\r\n     */\r\n    public static getXMLContent(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = new XMLSerializer().serializeToString(element);\r\n        const tagName = element.nodeName;\r\n        const reStartMsg: RegExp = new RegExp('<' + tagName + '[^>]*>', 'g');\r\n        result = result.replace(reStartMsg, '');\r\n        const reEndMsg: RegExp = new RegExp('</' + tagName + '>', 'g');\r\n        result = result.replace(reEndMsg, '');\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * return PCDATA content of element.\r\n     * @param element element\r\n     * @return PCDATA content of element.\r\n     */\r\n    public static getPCDATA(element: Element): string {\r\n        if (!element) {\r\n            return null;\r\n        }\r\n        let result = '';\r\n        const childNodes = element.childNodes;\r\n        for (let i = 0; i < childNodes.length; i++) {\r\n            const child = childNodes.item(i);\r\n            if (child.nodeType === child.TEXT_NODE || child.nodeType === child.CDATA_SECTION_NODE) {\r\n                result = result + child.nodeValue;\r\n            }\r\n        }\r\n        return result.length === 0 ? null : result;\r\n    }\r\n\r\n    /**\r\n     * replace PCDATA content with a new one.\r\n     * @param element element\r\n     * @param pcdata pcdata\r\n     */\r\n    public static replaceContentWithXMLContent(element: Element, pcdata: string) {\r\n        // remove all children\r\n        while (element.firstChild) {\r\n            element.removeChild(element.firstChild);\r\n        }\r\n        // parseICUMessage pcdata\r\n        const pcdataFragment: Document = new DOMParser().parseFromString('<fragment>' + pcdata + '</fragment>', 'application/xml');\r\n        const newChildren = pcdataFragment.getElementsByTagName('fragment').item(0).childNodes;\r\n        for (let j = 0; j < newChildren.length; j++) {\r\n            const newChild = newChildren.item(j);\r\n            element.appendChild(element.ownerDocument.importNode(newChild, true));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * find the previous sibling that is an element.\r\n     * @param element element\r\n     * @return the previous sibling that is an element or null.\r\n     */\r\n    public static getPreviousElementSibling(element: Node): Element {\r\n        let node = element.previousSibling;\r\n        while (node !== null) {\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                return <Element> node;\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Create an Element Node that is the next sibling of a given node.\r\n     * @param elementNameToCreate elementNameToCreate\r\n     * @param previousSibling previousSibling\r\n     * @return new element\r\n     */\r\n    public static createFollowingSibling(elementNameToCreate: string, previousSibling: Node): Element {\r\n        const newElement = previousSibling.ownerDocument.createElement(elementNameToCreate);\r\n        return <Element> DOMUtilities.insertAfter(newElement, previousSibling);\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly after previousSibling.\r\n     * @param newElement newElement\r\n     * @param previousSibling previousSibling\r\n     */\r\n    public static insertAfter(newElement: Node, previousSibling: Node): Node {\r\n        if (previousSibling.nextSibling !== null) {\r\n            previousSibling.parentNode.insertBefore(newElement, previousSibling.nextSibling);\r\n        } else {\r\n            previousSibling.parentNode.appendChild(newElement);\r\n        }\r\n        return newElement;\r\n    }\r\n\r\n    /**\r\n     * Insert newElement directly before nextSibling.\r\n     * @param newElement newElement\r\n     * @param nextSibling nextSibling\r\n     */\r\n    public static insertBefore(newElement: Node, nextSibling: Node): Node {\r\n        nextSibling.parentNode.insertBefore(newElement, nextSibling);\r\n        return newElement;\r\n    }\r\n}\r\n","/**\r\n * Created by martin on 05.05.2017.\r\n * A part of a parsed message.\r\n * Can be a text, a placeholder, a tag\r\n */\r\n\r\nexport enum ParsedMessagePartType {\r\n    TEXT,\r\n    PLACEHOLDER,\r\n    START_TAG,\r\n    END_TAG,\r\n    EMPTY_TAG,\r\n    ICU_MESSAGE,\r\n    ICU_MESSAGE_REF\r\n}\r\n\r\nexport abstract class ParsedMessagePart {\r\n\r\n    constructor(public type: ParsedMessagePartType) {\r\n\r\n    }\r\n\r\n    /**\r\n     * String representation of the part.\r\n     * @param format optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    public abstract asDisplayString(format?: string): string;\r\n\r\n}\r\n","/**\r\n * An XmlSerializer that supports formatting.\r\n * Original code is based on [xmldom](https://www.npmjs.com/package/xmldom)\r\n * It is extended to support formatting including handling of elements with mixed content.\r\n * Example formatted output:\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with\r\n *             <b>mixed</b>\r\n *              content\r\n *         </element>\r\n *     </doc>\r\n * </pre>\r\n * Same when \"element\" is indicated as \"mixedContentElement\":\r\n * <pre>\r\n *     <doc>\r\n *         <element>An element with <b>mixed</b> content</element>\r\n *     </doc>\r\n * </pre>\r\n */\r\n\r\ninterface Namespace {\r\n    prefix: string;\r\n    namespace: string;\r\n}\r\n\r\n/**\r\n * Options used to control the formatting\r\n */\r\nexport interface XmlSerializerOptions {\r\n    beautify?: boolean; // set to activate beautify\r\n    indentString?: string; // Sequence uses for indentation, must only contain white space chars, e.g. \"  \" or \"    \" or \"\\t\"\r\n    mixedContentElements?: string[]; // Names of elements containing mixed content (these are not beautified)\r\n}\r\n\r\nconst DEFAULT_INDENT_STRING = '  ';\r\n\r\nexport class XmlSerializer {\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    /**\r\n     * Serialze xml document to string.\r\n     * @param document the document\r\n     * @param options can be used to activate beautifying.\r\n     */\r\n    serializeToString(document: Document, options?: XmlSerializerOptions): string {\r\n        const buf = [];\r\n        let visibleNamespaces: Namespace[] = [];\r\n        const refNode = document.documentElement;\r\n        let prefix = refNode.prefix;\r\n        const uri = refNode.namespaceURI;\r\n\r\n        if (uri && prefix == null) {\r\n            prefix = refNode.lookupPrefix(uri);\r\n            if (prefix == null) {\r\n                visibleNamespaces = [\r\n                    {namespace: uri, prefix: null}\r\n                    // {namespace:uri,prefix:''}\r\n                ];\r\n            }\r\n        }\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        if (options.indentString) {\r\n            if (!this.containsOnlyWhiteSpace(options.indentString)) {\r\n                throw new Error('indentString must not contain non white characters');\r\n            }\r\n        }\r\n        this.doSerializeToString(document, options, buf, 0, false, visibleNamespaces);\r\n        return buf.join('');\r\n    }\r\n\r\n    /**\r\n     * Main format method that does all the work.\r\n     * Outputs a node to the outputbuffer.\r\n     * @param node the node to be formatted.\r\n     * @param options options\r\n     * @param buf outputbuffer, new output will be appended to this array.\r\n     * @param indentLevel Lever of indentation for formatted output.\r\n     * @param partOfMixedContent true, if node is a subelement of an element containind mixed content.\r\n     * @param visibleNamespaces visibleNamespaces\r\n     */\r\n    private doSerializeToString(node: Node, options: XmlSerializerOptions, buf: string[],\r\n                                indentLevel: number, partOfMixedContent: boolean, visibleNamespaces: Namespace[]) {\r\n        let child: Node;\r\n        switch (node.nodeType) {\r\n            case node.ELEMENT_NODE:\r\n                const elementNode: Element = <Element> node;\r\n                const attrs = elementNode.attributes;\r\n                const len = attrs.length;\r\n                child = elementNode.firstChild;\r\n                const nodeName = elementNode.tagName;\r\n                const elementHasMixedContent = this.isMixedContentElement(nodeName, options);\r\n                if (partOfMixedContent) {\r\n                    buf.push('<' , nodeName);\r\n                } else {\r\n                    this.outputIndented(options, buf, indentLevel, '<' , nodeName);\r\n                }\r\n\r\n                for (let i = 0; i < len; i++) {\r\n                    // add namespaces for attributes\r\n                    const attr = attrs.item(i);\r\n                    if (attr.prefix === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: attr.localName, namespace: attr.value});\r\n                    } else if (attr.nodeName === 'xmlns') {\r\n                        visibleNamespaces.push({prefix: '', namespace: attr.value});\r\n                    }\r\n                }\r\n                for (let i = 0; i < len; i++) {\r\n                    const attr = attrs.item(i);\r\n                    if (this.needNamespaceDefine(attr, visibleNamespaces)) {\r\n                        const prefix = attr.prefix || '';\r\n                        const uri = attr.namespaceURI;\r\n                        const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                        buf.push(ns, '=\"', uri, '\"');\r\n                        visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                    }\r\n                    this.doSerializeToString(attr, options, buf, indentLevel, false, visibleNamespaces);\r\n                }\r\n                // add namespace for current node\r\n                if (this.needNamespaceDefine(elementNode, visibleNamespaces)) {\r\n                    const prefix = elementNode.prefix || '';\r\n                    const uri = node.namespaceURI;\r\n                    const ns = prefix ? ' xmlns:' + prefix : ' xmlns';\r\n                    buf.push(ns, '=\"', uri, '\"');\r\n                    visibleNamespaces.push({prefix: prefix, namespace: uri});\r\n                }\r\n\r\n                if (child) {\r\n                    buf.push('>');\r\n                    // if is cdata child node\r\n                    let hasComplexContent = false;\r\n                    while (child) {\r\n                        if (child.nodeType === child.ELEMENT_NODE) {\r\n                            hasComplexContent = true;\r\n                        }\r\n                        this.doSerializeToString(child, options, buf, indentLevel + 1,\r\n                            partOfMixedContent || elementHasMixedContent, visibleNamespaces);\r\n                        child = child.nextSibling;\r\n                    }\r\n                    if (!partOfMixedContent && !elementHasMixedContent && hasComplexContent) {\r\n                        this.outputIndented(options, buf, indentLevel, '</', nodeName, '>');\r\n                    } else {\r\n                        buf.push('</', nodeName, '>');\r\n                    }\r\n                } else {\r\n                    buf.push('/>');\r\n                }\r\n                return;\r\n            case node.DOCUMENT_NODE:\r\n            case node.DOCUMENT_FRAGMENT_NODE:\r\n                child = node.firstChild;\r\n                while (child) {\r\n                    this.doSerializeToString(child, options, buf, indentLevel, false, visibleNamespaces);\r\n                    child = child.nextSibling;\r\n                }\r\n                return;\r\n            case node.ATTRIBUTE_NODE:\r\n                const attrNode = <Attr> node;\r\n                return buf.push(' ', attrNode.name, '=\"', attrNode.value.replace(/[<&\"]/g, this._xmlEncoder), '\"');\r\n            case node.TEXT_NODE:\r\n                const textNode = <Text> node;\r\n                if (!options.beautify || partOfMixedContent || !this.containsOnlyWhiteSpace(textNode.data)) {\r\n                    return buf.push(textNode.data.replace(/[<&]/g, this._xmlEncoder));\r\n                }\r\n                return;\r\n            case node.CDATA_SECTION_NODE:\r\n                const cdatasectionNode = <CDATASection> node;\r\n                return buf.push('<![CDATA[', cdatasectionNode.data, ']]>');\r\n            case node.COMMENT_NODE:\r\n                const commentNode = <Comment> node;\r\n                return buf.push('<!--', commentNode.data, '-->');\r\n            case node.DOCUMENT_TYPE_NODE:\r\n                const documenttypeNode = <DocumentType> node;\r\n                const pubid = documenttypeNode.publicId;\r\n                const sysid = documenttypeNode.systemId;\r\n                buf.push('<!DOCTYPE ', documenttypeNode.name);\r\n                if (pubid) {\r\n                    buf.push(' PUBLIC \"', pubid);\r\n                    if (sysid && sysid !== '.') {\r\n                        buf.push('\" \"', sysid);\r\n                    }\r\n                    buf.push('\">');\r\n                } else if (sysid && sysid !== '.') {\r\n                    buf.push(' SYSTEM \"', sysid, '\">');\r\n                } else {\r\n                    buf.push('>');\r\n                }\r\n                return;\r\n            case node.PROCESSING_INSTRUCTION_NODE:\r\n                const piNode = <ProcessingInstruction> node;\r\n                return buf.push( '<?', piNode.target, ' ', piNode.data, '?>');\r\n            case node.ENTITY_REFERENCE_NODE:\r\n                return buf.push('&', node.nodeName, ';');\r\n            // case ENTITY_NODE:\r\n            // case NOTATION_NODE:\r\n            default:\r\n                buf.push('??', node.nodeName);\r\n        }\r\n    }\r\n\r\n    private needNamespaceDefine(node: Element | Attr, visibleNamespaces: Namespace[]): boolean {\r\n        const prefix = node.prefix || '';\r\n        const uri = node.namespaceURI;\r\n        if (!prefix && !uri) {\r\n            return false;\r\n        }\r\n        if (prefix === 'xml' && uri === 'http://www.w3.org/XML/1998/namespace'\r\n            || uri === 'http://www.w3.org/2000/xmlns/') {\r\n            return false;\r\n        }\r\n\r\n        let i = visibleNamespaces.length;\r\n        while (i--) {\r\n            const ns = visibleNamespaces[i];\r\n            // get namespace prefix\r\n            if (ns.prefix === prefix) {\r\n                return ns.namespace !== uri;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    private _xmlEncoder(c: string): string {\r\n        return c === '<' && '&lt;' ||\r\n            c === '>' && '&gt;' ||\r\n            c === '&' && '&amp;' ||\r\n            c === '\"' && '&quot;' ||\r\n            '&#' + c.charCodeAt(0) + ';';\r\n    }\r\n\r\n    private outputIndented(options: XmlSerializerOptions, buf: string[], indentLevel: number, ...outputParts: string[]) {\r\n        if (options.beautify) {\r\n            buf.push('\\n');\r\n            if (indentLevel > 0) {\r\n                buf.push(this.indentationString(options, indentLevel));\r\n            }\r\n        }\r\n        buf.push(...outputParts);\r\n    }\r\n\r\n    private indentationString(options: XmlSerializerOptions, indentLevel: number): string {\r\n        const indent = (options.indentString) ? options.indentString : DEFAULT_INDENT_STRING;\r\n        let result = '';\r\n        for (let i = 0; i < indentLevel; i++) {\r\n            result = result + indent;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Test, wether tagName is an element containing mixed content.\r\n     * @param tagName tagName\r\n     * @param options options\r\n     */\r\n    private isMixedContentElement(tagName: string, options: XmlSerializerOptions): boolean {\r\n        if (options && options.mixedContentElements) {\r\n            return !!options.mixedContentElements.find((tag) => tag === tagName);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    private containsOnlyWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            const c = text.charAt(i);\r\n            if (!(c === ' ' || c === '\\t' || c === '\\r' || c === '\\n')) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}\r\n","import { STATE_NEW, STATE_TRANSLATED } from '../api/constants';\r\nimport { ITranslationMessagesFile } from '../api/i-translation-messages-file';\r\nimport { INormalizedMessage } from '../api/i-normalized-message';\r\nimport { ITransUnit } from '../api/i-trans-unit';\r\nimport { isNullOrUndefined } from 'util';\r\nimport { DOMParser } from 'xmldom';\r\nimport { XmlSerializer, XmlSerializerOptions } from './xml-serializer';\r\n/**\r\n * Created by roobm on 09.05.2017.\r\n * Abstract superclass for all implementations of ITranslationMessagesFile.\r\n */\r\n\r\nexport abstract class AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    protected _filename: string;\r\n\r\n    protected _encoding: string;\r\n\r\n    protected _parsedDocument: Document;\r\n\r\n    protected _parsedOptionalMasterDocument: Document;\r\n\r\n    protected _fileEndsWithEOL: boolean;\r\n\r\n    // trans-unit elements and their id from the file\r\n    protected transUnits: ITransUnit[];\r\n\r\n    protected optionalMasterTransUnits: ITransUnit[];\r\n\r\n    protected _warnings: string[];\r\n\r\n    protected _numberOfTransUnitsWithMissingId: number;\r\n\r\n    protected _numberOfUntranslatedTransUnits: number;\r\n\r\n    protected _numberOfReviewedTransUnits: number;\r\n\r\n    protected targetPraefix: string;\r\n\r\n    protected targetSuffix: string;\r\n\r\n    protected constructor() {\r\n        this.transUnits = null;\r\n        this._warnings = [];\r\n    }\r\n\r\n    /**\r\n     * Parse file content.\r\n     * Sets _parsedDocument, line ending, encoding, etc.\r\n     * @param xmlString xmlString\r\n     * @param path path\r\n     * @param encoding encoding\r\n     * @param optionalMaster optionalMaster\r\n     */\r\n    protected parseContent(\r\n        xmlString: string,\r\n        path: string, encoding: string,\r\n        optionalMaster?: { xmlContent: string, path: string, encoding: string })\r\n        : void {\r\n        this._filename = path;\r\n        this._encoding = encoding;\r\n        this._parsedDocument = new DOMParser().parseFromString(xmlString, 'text/xml');\r\n        if (optionalMaster) {\r\n            this._parsedOptionalMasterDocument = new DOMParser().parseFromString(optionalMaster.xmlContent, 'text/xml');\r\n        }\r\n        this._fileEndsWithEOL = xmlString.endsWith('\\n');\r\n    }\r\n\r\n    abstract i18nFormat(): string;\r\n\r\n    abstract fileType(): string;\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected abstract elementsWithMixedContent(): string[];\r\n\r\n    /**\r\n     * Read all trans units from xml content.\r\n     * Puts the found units into transUnits.\r\n     * Puts warnings for missing ids.\r\n     */\r\n    protected abstract initializeTransUnits();\r\n\r\n    protected lazyInitializeTransUnits() {\r\n        if (isNullOrUndefined(this.transUnits)) {\r\n            this.initializeTransUnits();\r\n            this.countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * count units after changes of trans units\r\n     */\r\n    public countNumbers() {\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this._numberOfUntranslatedTransUnits = 0;\r\n        this._numberOfReviewedTransUnits = 0;\r\n        this.forEachTransUnit((tu: ITransUnit) => {\r\n            if (isNullOrUndefined(tu.id) || tu.id === '') {\r\n                this._numberOfTransUnitsWithMissingId++;\r\n            }\r\n            const state = tu.targetState();\r\n            if (isNullOrUndefined(state) || state === STATE_NEW) {\r\n                this._numberOfUntranslatedTransUnits++;\r\n            }\r\n            if (state === STATE_TRANSLATED) {\r\n                this._numberOfReviewedTransUnits++;\r\n            }\r\n        });\r\n    }\r\n\r\n    public warnings(): string[] {\r\n        this.lazyInitializeTransUnits();\r\n        return this._warnings;\r\n    }\r\n\r\n    /**\r\n     * Total number of translation units found in the file.\r\n     */\r\n    public numberOfTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.length;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    numberOfUntranslatedTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfUntranslatedTransUnits;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units with state 'final'.\r\n     */\r\n    numberOfReviewedTransUnits(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfReviewedTransUnits;\r\n    }\r\n\r\n    /**\r\n     * Number of translation units without translation found in the file.\r\n     * These units have state 'translated'.\r\n     */\r\n    public numberOfTransUnitsWithMissingId(): number {\r\n        this.lazyInitializeTransUnits();\r\n        return this._numberOfTransUnitsWithMissingId;\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    abstract sourceLanguage(): string;\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    abstract targetLanguage(): string;\r\n\r\n    /**\r\n     * Loop over all Translation Units.\r\n     * @param callback callback\r\n     */\r\n    public forEachTransUnit(callback: ((transunit: ITransUnit) => void)) {\r\n        this.lazyInitializeTransUnits();\r\n        this.transUnits.forEach((tu) => callback(tu));\r\n    }\r\n\r\n    /**\r\n     * Get trans-unit with given id.\r\n     * @param id id\r\n     * @return trans-unit with given id.\r\n     */\r\n    public transUnitWithId(id: string): ITransUnit {\r\n        this.lazyInitializeTransUnits();\r\n        return this.transUnits.find((tu) => tu.id === id);\r\n    }\r\n\r\n    /**\r\n     * Get optional trans-unit with given id.\r\n     * @param id id\r\n     * @return trans-unit with given id.\r\n     */\r\n    public optionalMasterTransUnitWithId(id: string): ITransUnit {\r\n        this.lazyInitializeTransUnits();\r\n        return this.optionalMasterTransUnits.find((tu) => tu.id === id);\r\n    }\r\n\r\n    /**\r\n     * Edit functions following her\r\n     */\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    abstract setSourceLanguage(language: string);\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    abstract setTargetLanguage(language: string);\r\n\r\n    /**\r\n     * Set the praefix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetPraefix targetPraefix\r\n     */\r\n    public setNewTransUnitTargetPraefix(targetPraefix: string) {\r\n        this.targetPraefix = targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Get the praefix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the praefix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetPraefix(): string {\r\n        return isNullOrUndefined(this.targetPraefix) ? '' : this.targetPraefix;\r\n    }\r\n\r\n    /**\r\n     * Set the suffix used when copying source to target.\r\n     * This is used by importNewTransUnit and createTranslationFileForLang methods.\r\n     * (since 1.8.0)\r\n     * @param targetSuffix targetSuffix\r\n     */\r\n    public setNewTransUnitTargetSuffix(targetSuffix: string) {\r\n        this.targetSuffix = targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * Get the suffix used when copying source to target.\r\n     * (since 1.8.0)\r\n     * @return the suffix used when copying source to target.\r\n     */\r\n    getNewTransUnitTargetSuffix(): string {\r\n        return isNullOrUndefined(this.targetSuffix) ? '' : this.targetSuffix;\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    abstract importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit;\r\n\r\n    /**\r\n     * Remove the trans-unit with the given id.\r\n     * @param id id\r\n     */\r\n    public removeTransUnitWithId(id: string) {\r\n        const tuNode: Node = this._parsedDocument.getElementById(id);\r\n        if (tuNode) {\r\n            tuNode.parentNode.removeChild(tuNode);\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits = this.transUnits.filter((tu) => tu.id !== id);\r\n            this.countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The filename where the data is read from.\r\n     */\r\n    public filename(): string {\r\n        return this._filename;\r\n    }\r\n\r\n    /**\r\n     * The encoding if the xml content (UTF-8, ISO-8859-1, ...)\r\n     */\r\n    public encoding(): string {\r\n        return this._encoding;\r\n    }\r\n\r\n    /**\r\n     * The xml content to be saved after changes are made.\r\n     * @param beautifyOutput Flag whether to use pretty-data to format the output.\r\n     * XMLSerializer produces some correct but strangely formatted output, which pretty-data can correct.\r\n     * See issue #64 for details.\r\n     * Default is false.\r\n     */\r\n    public editedContent(beautifyOutput?: boolean): string {\r\n        const options: XmlSerializerOptions = {};\r\n        if (beautifyOutput === true) {\r\n            options.beautify = true;\r\n            options.indentString = '  ';\r\n            options.mixedContentElements = this.elementsWithMixedContent();\r\n        }\r\n        const result = new XmlSerializer().serializeToString(this._parsedDocument, options);\r\n        if (this._fileEndsWithEOL) {\r\n            // add eol if there was eol in original source\r\n            return result + '\\n';\r\n        } else {\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    abstract createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean, optionalMaster?: {xmlContent: string, path: string, encoding: string})\r\n        : ITranslationMessagesFile;\r\n}\r\n","import {STATE_TRANSLATED, ITranslationMessagesFile, INormalizedMessage, ITransUnit, INote} from './internalapi';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {isNullOrUndefined, isString} from 'util';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * Abstract superclass for all implementations of ITransUnit.\r\n */\r\n\r\nexport abstract class AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceContentNormalized: ParsedMessage;\r\n\r\n    protected constructor(protected _element: Element,\r\n                          protected _id: string,\r\n                          protected _translationMessagesFile: ITranslationMessagesFile) {\r\n    }\r\n\r\n    public get id(): string {\r\n        return this._id;\r\n    }\r\n\r\n    /**\r\n     * The file the unit belongs to.,\r\n     */\r\n    translationMessagesFile(): ITranslationMessagesFile {\r\n        return this._translationMessagesFile;\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated.\r\n     * Contains all markup, depends on the concrete format used.\r\n     */\r\n    abstract sourceContent(): string;\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    abstract setSourceContent(newContent: string);\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public sourceContentNormalized(): ParsedMessage {\r\n        if (isNullOrUndefined(this._sourceContentNormalized)) {\r\n            this._sourceContentNormalized = this.createSourceContentNormalized();\r\n        }\r\n        return this._sourceContentNormalized;\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    abstract createSourceContentNormalized(): ParsedMessage;\r\n\r\n    /**\r\n     * The translated value.\r\n     * Contains all markup, depends on the concrete format used.\r\n     */\r\n    abstract targetContent(): string;\r\n\r\n    /**\r\n     * The translated value as normalized message.\r\n     * All placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    abstract targetContentNormalized(): INormalizedMessage;\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    abstract nativeTargetState(): string;\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (on of new, translated, final)\r\n     * Return values are defined as Constants STATE_...\r\n     */\r\n    public targetState(): string {\r\n        const nativeState = this.nativeTargetState();\r\n        return this.mapNativeStateToState(nativeState);\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected abstract mapStateToNativeState(state: string): string;\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected abstract mapNativeStateToState(nativeState: string): string;\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected abstract setNativeTargetState(nativeState: string);\r\n\r\n    /**\r\n     * Modify the target state.\r\n     * @param newState one of the 3 allowed target states new, translated, final.\r\n     * Constants STATE_...\r\n     * Invalid states throw an error.\r\n     */\r\n    setTargetState(newState: string) {\r\n        this.setNativeTargetState(this.mapStateToNativeState(newState));\r\n        if (this.translationMessagesFile() instanceof AbstractTranslationMessagesFile) {\r\n            (<AbstractTranslationMessagesFile> this.translationMessagesFile()).countNumbers();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    abstract sourceReferences(): {sourcefile: string, linenumber: number}[];\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    abstract setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]);\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     */\r\n    abstract description(): string;\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     */\r\n    abstract meaning(): string;\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    abstract setDescription(description: string);\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    abstract setMeaning(meaning: string);\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    abstract notes(): INote[];\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    abstract supportsSetNotes(): boolean;\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains descpription or meaning as from attribute.\r\n     */\r\n    abstract setNotes(newNotes: INote[]);\r\n\r\n    /**\r\n     * Check notes\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    protected checkNotes(newNotes: INote[]) {\r\n        // check from values\r\n        const errorInFromNote = newNotes.find((note) => note.from === 'description' || note.from === 'meaning');\r\n        if (!isNullOrUndefined(errorInFromNote)) {\r\n            throw new Error('description or meaning are not allowed as from atttribute');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The real xml element used for the trans unit.\r\n     * (internal usage only, a client should never need this)\r\n     * @return real xml element used for the trans unit.\r\n     */\r\n    public asXmlElement(): Element {\r\n        return this._element;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    abstract cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit;\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    abstract useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean);\r\n\r\n    /**\r\n     * Translate the trans unit.\r\n     * @param translation the translated string or (preferred) a normalized message.\r\n     * The pure string can contain any markup and will not be checked.\r\n     * So it can damage the document.\r\n     * A normalized message prevents this.\r\n     */\r\n    public translate(translation: string | INormalizedMessage) {\r\n        let translationNative: string;\r\n        if (isString(translation)) {\r\n            translationNative = <string> translation;\r\n        } else {\r\n            translationNative = (<INormalizedMessage> translation).asNativeString();\r\n        }\r\n        this.translateNative(translationNative);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected abstract messageParser(): AbstractMessageParser;\r\n\r\n    /**\r\n     * Test, wether message looks like ICU message.\r\n     * @param message message\r\n     * @return wether message looks like ICU message.\r\n     */\r\n    public isICUMessage(message: string): boolean {\r\n        return this.messageParser().isICUMessageStart(message);\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected abstract translateNative(translation: string);\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of just simple text.\r\n */\r\n\r\nexport class ParsedMessagePartText extends ParsedMessagePart {\r\n\r\n    private text: string;\r\n\r\n    constructor(text: string) {\r\n        super(ParsedMessagePartType.TEXT);\r\n        this.text = text;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return this.text;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {NORMALIZATION_FORMAT_NGXTRANSLATE} from '../api/constants';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a placeholder.\r\n * Placeholders are numbered from 0 to n.\r\n */\r\n\r\nexport class ParsedMessagePartPlaceholder extends ParsedMessagePart {\r\n\r\n    // index 0 .. n\r\n    private _index: number;\r\n    // optional disp-Attribute value, contains the original expression.\r\n    private _disp?: string;\r\n\r\n    constructor(index: number, disp: string) {\r\n        super(ParsedMessagePartType.PLACEHOLDER);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (format === NORMALIZATION_FORMAT_NGXTRANSLATE) {\r\n            return '{{' + this._index + '}}';\r\n        }\r\n        return '{{' + this._index + '}}';\r\n    }\r\n    public index(): number {\r\n        return this._index;\r\n    }\r\n\r\n    public disp(): string {\r\n        return this._disp;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of an opening tag like <b> or <strange>.\r\n */\r\n\r\nexport class ParsedMessagePartStartTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n    private _idcounter: number;\r\n\r\n    constructor(tagname: string, idcounter: number) {\r\n        super(ParsedMessagePartType.START_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        } else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n    public idCounter(): number {\r\n        return this._idcounter;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message part consisting of a closing tag like </b> or </strange>.\r\n */\r\n\r\nexport class ParsedMessagePartEndTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n\r\n    constructor(tagname: string) {\r\n        super(ParsedMessagePartType.END_TAG);\r\n        this._tagname = tagname;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return '</' + this._tagname + '>';\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n}\r\n","import * as Tokenizr from 'tokenizr';\r\n\r\n/**\r\n * Created by martin on 04.06.2017.\r\n * A tokenizer for ICU messages.\r\n */\r\n\r\n// Tokens\r\nexport const TEXT = 'TEXT';\r\nexport const CURLY_BRACE_OPEN = 'CURLY_BRACE_OPEN';\r\nexport const CURLY_BRACE_CLOSE = 'CURLY_BRACE_CLOSE';\r\nexport const COMMA = 'COMMA';\r\nexport const PLURAL = 'PLURAL';\r\nexport const SELECT = 'SELECT';\r\n\r\nexport interface ICUToken {\r\n    type: string;\r\n    value: any;\r\n}\r\n\r\n// states: default normal in_message\r\nconst STATE_DEFAULT = 'default';\r\nconst STATE_NORMAL = 'normal';\r\nconst STATE_IN_MESSAGE = 'in_message';\r\n\r\nexport class ICUMessageTokenizer {\r\n    private lexer: Tokenizr.default;\r\n\r\n    private getLexer(): Tokenizr.default {\r\n        const lexer = new Tokenizr.default();\r\n        let plaintext = '';\r\n        let openedCurlyBracesInTextCounter = 0;\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT) {\r\n                if (this.containsNonWhiteSpace(plaintext)) {\r\n                    ctx.accept(TEXT, plaintext);\r\n                    plaintext = '';\r\n                } else {\r\n                    ctx.ignore();\r\n                }\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (this.containsNonWhiteSpace(plaintext)) {\r\n                ctx.accept(TEXT, plaintext);\r\n            }\r\n         });\r\n        // curly brace\r\n        lexer.rule(STATE_DEFAULT, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_NORMAL);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /{/, (ctx, match) => {\r\n            ctx.accept(CURLY_BRACE_OPEN, match[0]);\r\n            ctx.push(STATE_IN_MESSAGE);\r\n        }, CURLY_BRACE_OPEN);\r\n        lexer.rule(STATE_NORMAL, /}/, (ctx, match) => {\r\n            ctx.pop();\r\n            ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n        }, CURLY_BRACE_CLOSE);\r\n        // masked ' { and }\r\n        lexer.rule(STATE_IN_MESSAGE, /'[{}]?'/, (ctx, match) => {\r\n            if (match[0] === '\\'\\'') {\r\n                plaintext += '\\'';\r\n            } else if (match[0] === '\\'{\\'') {\r\n                plaintext += '{';\r\n            } else if (match[0] === '\\'}\\'') {\r\n                plaintext += '}';\r\n            }\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(STATE_IN_MESSAGE, /./, (ctx, match) => {\r\n            const char = match[0];\r\n            if (char === '{') {\r\n                openedCurlyBracesInTextCounter++;\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            } else if (char === '}') {\r\n                if (openedCurlyBracesInTextCounter > 0) {\r\n                    openedCurlyBracesInTextCounter--;\r\n                    plaintext += match[0];\r\n                    ctx.ignore();\r\n                } else {\r\n                    ctx.pop();\r\n                    ctx.accept(TEXT, plaintext);\r\n                    plaintext = '';\r\n                    ctx.accept(CURLY_BRACE_CLOSE, match[0]);\r\n                }\r\n            } else {\r\n                plaintext += match[0];\r\n                ctx.ignore();\r\n            }\r\n        }, TEXT);\r\n        // comma\r\n        lexer.rule(STATE_NORMAL, /,/, (ctx, match) => {\r\n            ctx.accept(COMMA, match[0]);\r\n        }, COMMA);\r\n        // keywords plural and select\r\n        lexer.rule(STATE_NORMAL, /plural/, (ctx, match) => {\r\n            ctx.accept(PLURAL, match[0]);\r\n        }, PLURAL);\r\n        lexer.rule(STATE_NORMAL, /select/, (ctx, match) => {\r\n            ctx.accept(SELECT, match[0]);\r\n        }, SELECT);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\s]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n\r\n    private containsNonWhiteSpace(text: string): boolean {\r\n        for (let i = 0; i < text.length; i++) {\r\n            if (!/\\s/.test(text.charAt(i))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    tokenize(normalizedMessage: string): ICUToken[] {\r\n        const lexer: Tokenizr.default = this.getLexer();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n\r\n    input(normalizedMessage: string) {\r\n        this.lexer = this.getLexer();\r\n        this.lexer.input(normalizedMessage);\r\n    }\r\n\r\n    next(): ICUToken {\r\n        return this.lexer.token();\r\n    }\r\n\r\n    peek(): ICUToken {\r\n        return this.lexer.peek();\r\n    }\r\n}\r\n","import {IICUMessage, IICUMessageCategory, IICUMessageTranslation, INormalizedMessage} from '../api/index';\r\nimport {format, isNullOrUndefined, isString} from 'util';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\nclass MessageCategory implements IICUMessageCategory {\r\n\r\n    constructor(private _category: string, private _message: INormalizedMessage) {}\r\n\r\n    public getCategory(): string {\r\n        return this._category;\r\n    }\r\n\r\n    public getMessageNormalized(): INormalizedMessage {\r\n        return this._message;\r\n    }\r\n}\r\n\r\n/**\r\n * Implementation of an ICU Message.\r\n * Created by martin on 05.06.2017.\r\n */\r\nexport class ICUMessage implements IICUMessage {\r\n\r\n    private _isPluralMessage: boolean;\r\n\r\n    private _categories: IICUMessageCategory[];\r\n\r\n    constructor(private _parser: IMessageParser, isPluralMessage: boolean) {\r\n        this._isPluralMessage = isPluralMessage;\r\n        this._categories = [];\r\n    }\r\n\r\n    addCategory(category: string, message: INormalizedMessage) {\r\n        this._categories.push(new MessageCategory(category, message));\r\n    }\r\n\r\n    /**\r\n     * ICU message as native string.\r\n     * This is, how it is stored, something like '{x, plural, =0 {..}'\r\n     * @return ICU message as native string.\r\n     */\r\n    public asNativeString(): string {\r\n        const varname = (this.isPluralMessage()) ? 'VAR_PLURAL' : 'VAR_SELECT';\r\n        const type = (this.isPluralMessage()) ? 'plural' : 'select';\r\n        let choiceString = '';\r\n        this._categories.forEach((category: IICUMessageCategory) => {\r\n            choiceString = choiceString + format(' %s {%s}', category.getCategory(), category.getMessageNormalized().asNativeString());\r\n        });\r\n        return format('{%s, %s,%s}', varname, type, choiceString);\r\n    }\r\n\r\n    /**\r\n     * Is it a plural message?\r\n     */\r\n    isPluralMessage(): boolean {\r\n        return this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * Is it a select message?\r\n     */\r\n    isSelectMessage(): boolean {\r\n        return !this._isPluralMessage;\r\n    }\r\n\r\n    /**\r\n     * All the parts of the message.\r\n     * E.g. the ICU message {wolves, plural, =0 {no wolves} =1 {one wolf} =2 {two wolves} other {a wolf pack}}\r\n     * has 4 category objects with the categories =0, =1, =2, other.\r\n     */\r\n    getCategories(): IICUMessageCategory[] {\r\n        return this._categories;\r\n    }\r\n\r\n    /**\r\n     * Translate message and return a new, translated message\r\n     * @param translation the translation (hashmap of categories and translations).\r\n     * @return new message wit translated content.\r\n     * @throws an error if translation does not match the message.\r\n     * This is the case, if there are categories not contained in the original message.\r\n     */\r\n    translate(translation: IICUMessageTranslation): IICUMessage {\r\n        const message = new ICUMessage(this._parser, this.isPluralMessage());\r\n        const translatedCategories: Set<string> = new Set<string>();\r\n        this._categories.forEach((category) => {\r\n            let translatedMessage: INormalizedMessage;\r\n            const translationForCategory: string|IICUMessageTranslation = translation[category.getCategory()];\r\n            if (isNullOrUndefined(translationForCategory)) {\r\n                translatedMessage = category.getMessageNormalized();\r\n            } else if (isString(translationForCategory)) {\r\n                translatedCategories.add(category.getCategory());\r\n                translatedMessage = this._parser.parseNormalizedString(<string> translationForCategory, null);\r\n            } else {\r\n                // TODO embedded ICU Message\r\n                translatedMessage = null;\r\n            }\r\n            message.addCategory(category.getCategory(), translatedMessage);\r\n        });\r\n        // new categories, which are not part of the original message\r\n        Object.keys(translation).forEach((categoryName) => {\r\n            if (!translatedCategories.has(categoryName)) {\r\n                if (this.isSelectMessage()) {\r\n                    throw new Error(format('adding a new category not allowed for select messages (\"%s\" is not part of message)',\r\n                        categoryName));\r\n                } else {\r\n                    this.checkValidPluralCategory(categoryName);\r\n                    // TODO embedded ICU Message\r\n                    let translatedMessage = this._parser.parseNormalizedString(<string> translation[categoryName], null);\r\n                    message.addCategory(categoryName, translatedMessage);\r\n                }\r\n            }\r\n        });\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Check, wether category is valid plural category.\r\n     * Allowed are =n, 'zero', 'one', 'two', 'few', 'many' and 'other'\r\n     * @param categoryName category\r\n     * @throws an error, if it is not a valid category name\r\n     */\r\n    private checkValidPluralCategory(categoryName: string) {\r\n        const allowedKeywords = ['zero', 'one', 'two', 'few', 'many', 'other'];\r\n        if (categoryName.match(/=\\d+/)) {\r\n            return;\r\n        }\r\n        if (allowedKeywords.find((key) => key === categoryName)) {\r\n            return;\r\n        }\r\n        throw new Error(format('invalid plural category \"%s\", allowed are =<n> and %s', categoryName, allowedKeywords));\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {IICUMessage, INormalizedMessage} from '../api/index';\r\nimport {\r\n    COMMA, CURLY_BRACE_CLOSE, CURLY_BRACE_OPEN, ICUMessageTokenizer, ICUToken, PLURAL, SELECT,\r\n    TEXT\r\n} from './icu-message-tokenizer';\r\nimport {ICUMessage} from './icu-message';\r\nimport {format} from 'util';\r\nimport {IMessageParser} from './i-message-parser';\r\n\r\n/**\r\n * Created by martin on 02.06.2017.\r\n * A message part consisting of an icu message.\r\n * There can only be one icu message in a parsed message.\r\n * Syntax of ICU message is '{' <keyname> ',' 'select'|'plural' ',' (<category> '{' text '}')+ '}'\r\n */\r\n\r\nexport class ParsedMessagePartICUMessage extends ParsedMessagePart {\r\n\r\n    private _message: ICUMessage;\r\n    private _messageText: string;\r\n    private _tokenizer: ICUMessageTokenizer;\r\n\r\n    constructor(icuMessageText: string, private _parser: IMessageParser) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE);\r\n        if (icuMessageText) {\r\n            this.parseICUMessage(icuMessageText);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test wether text might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param icuMessageText icuMessageText\r\n     * @return wether text might be an ICU message.\r\n     */\r\n    static looksLikeICUMessage(icuMessageText: string): boolean {\r\n        const part = new ParsedMessagePartICUMessage(null, null);\r\n        return part.looksLikeICUMessage(icuMessageText);\r\n    }\r\n\r\n    public asDisplayString(displayFormat?: string) {\r\n        return '<ICU-Message/>';\r\n    }\r\n\r\n    /**\r\n     * return the parsed message.\r\n     * @return parsed message\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        return this._message;\r\n    }\r\n\r\n    /**\r\n     * Parse the message.\r\n     * @param text message text to parse\r\n     * @throws an error if the syntax is not ok in any way.\r\n     */\r\n    private parseICUMessage(text: string) {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._messageText = text;\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        this.expectNext(CURLY_BRACE_OPEN);\r\n        this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n        this.expectNext(COMMA);\r\n        let token: ICUToken = this._tokenizer.next();\r\n        if (token.type === PLURAL) {\r\n            this._message = new ICUMessage(this._parser, true);\r\n        } else if (token.type === SELECT) {\r\n            this._message = new ICUMessage(this._parser, false);\r\n        }\r\n        this.expectNext(COMMA);\r\n        token = this._tokenizer.peek();\r\n        while (token.type !== CURLY_BRACE_CLOSE) {\r\n            const category = this.expectNext(TEXT).value.trim();\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            const message = this.expectNext(TEXT).value;\r\n            this._message.addCategory(category, this.parseNativeSubMessage(message));\r\n            this.expectNext(CURLY_BRACE_CLOSE);\r\n            token = this._tokenizer.peek();\r\n        }\r\n        this.expectNext(CURLY_BRACE_CLOSE);\r\n        this.expectNext('EOF');\r\n    }\r\n\r\n    /**\r\n     * Parse the message to check, wether it might be an ICU message.\r\n     * Should at least start with something like '{<name>, select, ..' or '{<name>, plural, ...'\r\n     * @param text message text to parse\r\n     */\r\n    private looksLikeICUMessage(text: string): boolean {\r\n        // console.log('message ', text);\r\n        // const tokens = new ICUMessageTokenizer().tokenize(text);\r\n        // tokens.forEach((tok) => {\r\n        //     console.log('Token', tok.type, tok.value);\r\n        // });\r\n        this._tokenizer = new ICUMessageTokenizer();\r\n        this._tokenizer.input(text);\r\n        try {\r\n            this.expectNext(CURLY_BRACE_OPEN);\r\n            this.expectNext(TEXT); // varname, not used currently, ng always used VAR_PLURAL or VAR_SELECT\r\n            this.expectNext(COMMA);\r\n            const token: ICUToken = this._tokenizer.next();\r\n            if (token.type !== PLURAL && token.type !== SELECT) {\r\n                return false;\r\n            }\r\n            this.expectNext(COMMA);\r\n            return true;\r\n        } catch (error) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Read next token and expect, that it is of the given type.\r\n     * @param tokentype expected type.\r\n     * @return Token\r\n     * @throws error, if next token has wrong type.\r\n     */\r\n    private expectNext(tokentype: string): ICUToken {\r\n        const token = this._tokenizer.next();\r\n        if (token.type !== tokentype) {\r\n            throw new Error(format('Error parsing ICU Message: expected %s, found %s (%s) (message %s)',\r\n                tokentype, token.type, token.value, this._messageText));\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /**\r\n     * Parse XML text to normalized message.\r\n     * @param message message in format dependent xml syntax.\r\n     * @return normalized message\r\n     */\r\n    private parseNativeSubMessage(message: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(message, null);\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {NORMALIZATION_FORMAT_NGXTRANSLATE} from '../api/constants';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A reference to an ICU message\r\n * icu references are numbered from 0 to n.\r\n */\r\n\r\nexport class ParsedMessagePartICUMessageRef extends ParsedMessagePart {\r\n\r\n    // index 0 .. n\r\n    private _index: number;\r\n    // optional disp-Attribute value, contains the original expression.\r\n    private _disp?: string;\r\n\r\n    constructor(index: number, disp: string) {\r\n        super(ParsedMessagePartType.ICU_MESSAGE_REF);\r\n        this._index = index;\r\n        this._disp = disp;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        return '<ICU-Message-Ref_' + this._index + '/>';\r\n    }\r\n\r\n    public index(): number {\r\n        return this._index;\r\n    }\r\n\r\n    public disp(): string {\r\n        return this._disp;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\n/**\r\n * Created by martin on 14.06.2017.\r\n * A message part consisting of an empty tag like <br/>.\r\n */\r\n\r\nexport class ParsedMessagePartEmptyTag extends ParsedMessagePart {\r\n\r\n    private _tagname: string;\r\n    private _idcounter: number;\r\n\r\n    constructor(tagname: string, idcounter: number) {\r\n        super(ParsedMessagePartType.EMPTY_TAG);\r\n        this._tagname = tagname;\r\n        this._idcounter = idcounter;\r\n    }\r\n\r\n    public asDisplayString(format?: string) {\r\n        if (this._idcounter === 0) {\r\n            return '<' + this._tagname + '>';\r\n        } else {\r\n            return '<' + this._tagname + ' id=\"' + this._idcounter.toString() + '\">';\r\n        }\r\n    }\r\n\r\n    public tagName(): string {\r\n        return this._tagname;\r\n    }\r\n\r\n    public idCounter(): number {\r\n        return this._idcounter;\r\n    }\r\n}\r\n","import {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {INormalizedMessage, ValidationErrors} from '../api/i-normalized-message';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {IMessageParser} from './i-message-parser';\r\nimport {format, isNullOrUndefined} from 'util';\r\nimport {IICUMessage, IICUMessageTranslation} from '../api/i-icu-message';\r\nimport {ParsedMessagePartICUMessage} from './parsed-message-part-icu-message';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ICUMessage} from './icu-message';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\n/**\r\n * Created by martin on 05.05.2017.\r\n * A message text read from a translation file.\r\n * Can contain placeholders, tags, text.\r\n * This class is a representation independent of the concrete format.\r\n */\r\nexport class ParsedMessage implements INormalizedMessage {\r\n\r\n    /**\r\n     * Parser that created this message (determines the native format).\r\n     */\r\n    private _parser: IMessageParser;\r\n\r\n    /**\r\n     * The message where this one stems from as translation.\r\n     * Optional, set only for messages created by calling translate.\r\n     */\r\n    private sourceMessage: ParsedMessage;\r\n\r\n    /**\r\n     * The parts of the message.\r\n     */\r\n    private _parts: ParsedMessagePart[];\r\n\r\n    /**\r\n     * messages xml representation.\r\n     */\r\n    private _xmlRepresentation: Element;\r\n\r\n    constructor(parser: IMessageParser, sourceMessage: ParsedMessage) {\r\n        this._parser = parser;\r\n        this.sourceMessage = sourceMessage;\r\n        this._parts = [];\r\n    }\r\n\r\n    /**\r\n     * Get the parser (for tests only, not part of API)\r\n     * @return parser\r\n     */\r\n    getParser(): IMessageParser {\r\n        return this._parser;\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized message as a translation of this one.\r\n     * @param normalizedString the translation in normalized form.\r\n     * If the message is an ICUMessage (getICUMessage returns a value), use translateICUMessage instead.\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is an ICU message.\r\n     */\r\n    translate(normalizedString: string): INormalizedMessage {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return this._parser.parseNormalizedString(<string> normalizedString, this);\r\n        } else {\r\n            throw new Error(format('cannot translate ICU message with simple string, use translateICUMessage() instead (\"%s\", \"%s\")',\r\n                normalizedString, this.asNativeString()));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized icu message as a translation of this one.\r\n     * @param icuTranslation the translation, this is the translation of the ICU message,\r\n     * which is not a string, but a collections of the translations of the different categories.\r\n     * The message must be an ICUMessage (getICUMessage returns a value)\r\n     * @throws an error if normalized string is not well formed.\r\n     * Throws an error too, if this is not an ICU message.\r\n     */\r\n    translateICUMessage(icuTranslation: IICUMessageTranslation): INormalizedMessage {\r\n        const icuMessage: IICUMessage = this.getICUMessage();\r\n        if (isNullOrUndefined(icuMessage)) {\r\n            throw new Error(format('this is not an ICU message, use translate() instead (\"%s\", \"%s\")',\r\n                icuTranslation,  this.asNativeString()));\r\n        } else {\r\n            const translatedICUMessage: IICUMessage = icuMessage.translate(icuTranslation);\r\n            return this._parser.parseICUMessage(translatedICUMessage.asNativeString(), this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new normalized message from a native xml string as a translation of this one.\r\n     * @param nativeString xml string in the format of the underlying file format.\r\n     * Throws an error if native string is not acceptable.\r\n     */\r\n    translateNativeString(nativeString: string): INormalizedMessage {\r\n        return this._parser.createNormalizedMessageFromXMLString(nativeString, this);\r\n    }\r\n\r\n    /**\r\n     * normalized message as string.\r\n     * @param displayFormat optional way to determine the exact syntax.\r\n     * Allowed formats are defined as constants NORMALIZATION_FORMAT...\r\n     */\r\n    public asDisplayString(displayFormat?: string) {\r\n        return this._parts.map((part) => part.asDisplayString(displayFormat)).join('');\r\n    }\r\n\r\n    /**\r\n     * Returns the message content as format dependent native string.\r\n     * Includes all format specific markup like <ph id=\"INTERPOLATION\" ../> ..\r\n     */\r\n    asNativeString(): string {\r\n        if (isNullOrUndefined(this.getICUMessage())) {\r\n            return DOMUtilities.getXMLContent(this._xmlRepresentation);\r\n        } else {\r\n            return this.getICUMessage().asNativeString();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Validate the message.\r\n     * @return null, if ok, error object otherwise.\r\n     */\r\n    public validate(): ValidationErrors | null {\r\n        let hasErrors = false;\r\n        const errors: ValidationErrors = {};\r\n        let e;\r\n        e = this.checkPlaceholderAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.placeholderAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefRemoved();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefRemoved = e;\r\n            hasErrors = true;\r\n        }\r\n        e = this.checkICUMessageRefAdded();\r\n        if (!isNullOrUndefined(e)) {\r\n            errors.icuMessageRefAdded = e;\r\n            hasErrors = true;\r\n        }\r\n        return hasErrors ? errors : null;\r\n    }\r\n\r\n    /**\r\n     * Validate the message, check for warnings only.\r\n     * A warning shows, that the message is acceptable, but misses something.\r\n     * E.g. if you remove a placeholder or a special tag from the original message, this generates a warning.\r\n     * @return null, if no warning, warnings as error object otherwise.\r\n     */\r\n    validateWarnings(): ValidationErrors | null {\r\n        let hasWarnings = false;\r\n        const warnings: ValidationErrors = {};\r\n        let w;\r\n        w = this.checkPlaceholderRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.placeholderRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagRemoved();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagRemoved = w;\r\n            hasWarnings = true;\r\n        }\r\n        w = this.checkTagAdded();\r\n        if (!isNullOrUndefined(w)) {\r\n            warnings.tagAdded = w;\r\n            hasWarnings = true;\r\n        }\r\n        return hasWarnings ? warnings : null;\r\n    }\r\n\r\n    /**\r\n     * Test wether this message is an ICU message.\r\n     * @return true, if it is an ICU message.\r\n     */\r\n    isICUMessage(): boolean {\r\n        return this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE;\r\n    }\r\n\r\n    /**\r\n     * Test wether this message contains an ICU message reference.\r\n     * ICU message references are something like <x ID=\"ICU\"../>.\r\n     * @return true, if there is an ICU message reference in the message.\r\n     */\r\n    containsICUMessageRef(): boolean {\r\n        return this._parts.findIndex(part => part.type === ParsedMessagePartType.ICU_MESSAGE_REF) >= 0;\r\n    }\r\n\r\n    /**\r\n     * If this message is an ICU message, returns its structure.\r\n     * Otherwise this method returns null.\r\n     * @return ICUMessage or null.\r\n     */\r\n    public getICUMessage(): IICUMessage {\r\n        if (this._parts.length === 1 && this._parts[0].type === ParsedMessagePartType.ICU_MESSAGE) {\r\n            const icuPart = <ParsedMessagePartICUMessage> this._parts[0];\r\n            return icuPart.getICUMessage();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Check for added placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkPlaceholderAdded(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            myPlaceholders.forEach((index) => {\r\n                if (!sourcePlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added placeholder ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added placeholders ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed placeholder.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkPlaceholderRemoved(): any {\r\n        let w = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourcePlaceholders = this.sourceMessage.allPlaceholders();\r\n            const myPlaceholders = this.allPlaceholders();\r\n            sourcePlaceholders.forEach((index) => {\r\n                if (!myPlaceholders.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            w = 'removed placeholder ' + suspiciousIndexes[0] + ' from original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            w = 'removed placeholders ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n\r\n    /**\r\n     * Check for added ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkICUMessageRefAdded(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            myICURefs.forEach((index) => {\r\n                if (!sourceICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'added ICU message reference ' + suspiciousIndexes[0] + ', which is not in original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'added ICU message references ' + allSuspiciousIndexes + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed ICU Message Refs.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkICUMessageRefRemoved(): any {\r\n        let e = null;\r\n        const suspiciousIndexes = [];\r\n        if (this.sourceMessage) {\r\n            const sourceICURefs = this.sourceMessage.allICUMessageRefs();\r\n            const myICURefs = this.allICUMessageRefs();\r\n            sourceICURefs.forEach((index) => {\r\n                if (!myICURefs.has(index)) {\r\n                    suspiciousIndexes.push(index);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousIndexes.length === 1) {\r\n            e = 'removed ICU message reference ' + suspiciousIndexes[0] + ' from original message';\r\n        } else if (suspiciousIndexes.length > 1) {\r\n            let allSuspiciousIndexes = '';\r\n            let first = true;\r\n            suspiciousIndexes.forEach((index) => {\r\n                if (!first) {\r\n                    allSuspiciousIndexes = allSuspiciousIndexes + ', ';\r\n                }\r\n                allSuspiciousIndexes = allSuspiciousIndexes + index;\r\n                first = false;\r\n            });\r\n            e = 'removed ICU message references ' + allSuspiciousIndexes + ' from original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Get all indexes of placeholders used in the message.\r\n     */\r\n    private allPlaceholders(): Set<number> {\r\n        const result = new Set<number>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const index = (<ParsedMessagePartPlaceholder> part).index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return the disp-Attribute of placeholder\r\n     * @param index index of placeholder\r\n     * @return disp or null\r\n     */\r\n    public getPlaceholderDisp(index: number): string {\r\n        let placeHolder: ParsedMessagePartPlaceholder = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.PLACEHOLDER) {\r\n                const phPart: ParsedMessagePartPlaceholder = <ParsedMessagePartPlaceholder> part;\r\n                if (phPart.index() === index) {\r\n                    placeHolder = phPart;\r\n                }\r\n            }\r\n        });\r\n        return placeHolder ? placeHolder.disp() : null;\r\n    }\r\n\r\n    /**\r\n     * Get all indexes of ICU message refs used in the message.\r\n     */\r\n    private allICUMessageRefs(): Set<number> {\r\n        const result = new Set<number>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const index = (<ParsedMessagePartICUMessageRef> part).index();\r\n                result.add(index);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return the disp-Attribute of icu message ref\r\n     * @param index of ref\r\n     * @return disp or null\r\n     */\r\n    public getICUMessageRefDisp(index: number): string {\r\n        let icuMessageRefPart: ParsedMessagePartICUMessageRef = null;\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.ICU_MESSAGE_REF) {\r\n                const refPart: ParsedMessagePartICUMessageRef = <ParsedMessagePartICUMessageRef> part;\r\n                if (refPart.index() === index) {\r\n                    icuMessageRefPart = refPart;\r\n                }\r\n            }\r\n        });\r\n        return icuMessageRefPart ? icuMessageRefPart.disp() : null;\r\n    }\r\n\r\n    /**\r\n     * Check for added tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkTagAdded(): any {\r\n        let e = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            myTags.forEach((tagName) => {\r\n                if (!sourceTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            e = 'added tag <' + suspiciousTags[0] + '>, which is not in original message';\r\n        } else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            e = 'added tags ' + allSuspiciousTags + ', which are not in original message';\r\n        }\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Check for removed tags.\r\n     * @return null or message, if fulfilled.\r\n     */\r\n    private checkTagRemoved(): any {\r\n        let w = null;\r\n        const suspiciousTags = [];\r\n        if (this.sourceMessage) {\r\n            const sourceTags = this.sourceMessage.allTags();\r\n            const myTags = this.allTags();\r\n            sourceTags.forEach((tagName) => {\r\n                if (!myTags.has(tagName)) {\r\n                    suspiciousTags.push(tagName);\r\n                }\r\n            });\r\n        }\r\n        if (suspiciousTags.length === 1) {\r\n            w = 'removed tag <' + suspiciousTags[0] + '> from original message';\r\n        } else if (suspiciousTags.length > 1) {\r\n            let allSuspiciousTags = '';\r\n            let first = true;\r\n            suspiciousTags.forEach((tag) => {\r\n                if (!first) {\r\n                    allSuspiciousTags = allSuspiciousTags + ', ';\r\n                }\r\n                allSuspiciousTags = allSuspiciousTags + '<' + tag + '>';\r\n                first = false;\r\n            });\r\n            w = 'removed tags ' + allSuspiciousTags + ' from original message';\r\n        }\r\n        return w;\r\n    }\r\n\r\n    /**\r\n     * Get all tag names used in the message.\r\n     */\r\n    private allTags(): Set<string> {\r\n        const result = new Set<string>();\r\n        this.parts().forEach((part) => {\r\n            if (part.type === ParsedMessagePartType.START_TAG || part.type === ParsedMessagePartType.EMPTY_TAG) {\r\n                const tagName = (<ParsedMessagePartStartTag> part).tagName();\r\n                result.add(tagName);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    public parts(): ParsedMessagePart[] {\r\n        return this._parts;\r\n    }\r\n\r\n    setXmlRepresentation(xmlRepresentation: Element) {\r\n        this._xmlRepresentation = xmlRepresentation;\r\n    }\r\n\r\n    addText(text: string) {\r\n        this._parts.push(new ParsedMessagePartText(text));\r\n    }\r\n\r\n    addPlaceholder(index: number, disp: string) {\r\n        this._parts.push(new ParsedMessagePartPlaceholder(index, disp));\r\n    }\r\n\r\n    addStartTag(tagname: string, idcounter: number) {\r\n        this._parts.push(new ParsedMessagePartStartTag(tagname, idcounter));\r\n    }\r\n\r\n    addEndTag(tagname: string) {\r\n        // check if well formed\r\n        const openTag = this.calculateOpenTagName();\r\n        if (!openTag || openTag !== tagname) {\r\n            // oops, not well formed\r\n            throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")',\r\n                tagname, openTag, this.asNativeString()));\r\n        }\r\n        this._parts.push(new ParsedMessagePartEndTag(tagname));\r\n    }\r\n\r\n    addEmptyTag(tagname: string, idcounter: number) {\r\n        this._parts.push(new ParsedMessagePartEmptyTag(tagname, idcounter));\r\n    }\r\n\r\n    addICUMessageRef(index: number, disp) {\r\n        this._parts.push(new ParsedMessagePartICUMessageRef(index, disp));\r\n    }\r\n\r\n    addICUMessage(text: string) {\r\n        this._parts.push(new ParsedMessagePartICUMessage(text, this._parser));\r\n    }\r\n\r\n    /**\r\n     * Determine, wether there is an open tag, that is not closed.\r\n     * Returns the latest one or null, if there is no open tag.\r\n     */\r\n    private calculateOpenTagName(): string {\r\n        const openTags = [];\r\n        this._parts.forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.START_TAG:\r\n                    openTags.push((<ParsedMessagePartStartTag> part).tagName());\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const tagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== tagName) {\r\n                        // oops, not well formed\r\n                        const openTag = (openTags.length === 0) ? 'nothing' : openTags[openTags.length - 1];\r\n                        throw new Error(format('unexpected close tag %s (currently open is %s, native xml is \"%s\")',\r\n                            tagName, openTag, this.asNativeString()));\r\n                    }\r\n                    openTags.pop();\r\n            }\r\n        });\r\n        return openTags.length === 0 ? null : openTags[openTags.length - 1];\r\n    }\r\n}\r\n","import * as Tokenizr from 'tokenizr';\r\nimport {isNullOrUndefined} from 'util';\r\n\r\n/**\r\n * Created by martin on 14.05.2017.\r\n * A tokenizer for normalized messages.\r\n */\r\n\r\n// Tokens\r\nexport const TEXT = 'TEXT';\r\nexport const START_TAG = 'START_TAG';\r\nexport const END_TAG = 'END_TAG';\r\nexport const EMPTY_TAG = 'EMPTY_TAG';\r\nexport const PLACEHOLDER = 'PLACEHOLDER';\r\nexport const ICU_MESSAGE_REF = 'ICU_MESSAGE_REF';\r\nexport const ICU_MESSAGE = 'ICU_MESSAGE';\r\n\r\nexport interface Token {\r\n    type: string;\r\n    value: any;\r\n}\r\n\r\nexport class ParsedMesageTokenizer {\r\n\r\n    private getLexer(): Tokenizr.default {\r\n        const lexer = new Tokenizr.default();\r\n        let plaintext = '';\r\n        lexer.before((ctx, match, rule) => {\r\n            if (rule.name !== TEXT && plaintext !== '') {\r\n                ctx.accept(TEXT, {text: plaintext});\r\n                plaintext = '';\r\n            }\r\n        });\r\n        lexer.finish((ctx) => {\r\n            if (plaintext !== '') {\r\n                ctx.accept(TEXT, {text: plaintext});\r\n            }\r\n         });\r\n        // empty tag, there are only a few allowed (see tag-mappings): ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR']\r\n        // format is <name id=\"nr\">, nr ist optional, z.B. <img> oder <img id=\"2\">\r\n        lexer.rule(/<(br|hr|img|area|link|wbr)( id=\"([0-9])*\")?\\>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(EMPTY_TAG, {name: match[1], idcounter: idcount});\r\n        }, EMPTY_TAG);\r\n        // start tag, Format <name id=\"nr\">, nr ist optional, z.B. <mytag> oder <mytag id=\"2\">\r\n        lexer.rule(/<([a-zA-Z][a-zA-Z-0-9]*)( id=\"([0-9]*)\")?>/, (ctx, match) => {\r\n            const idcount = isNullOrUndefined(match[3]) ? 0 : parseInt(match[3], 10);\r\n            ctx.accept(START_TAG, {name: match[1], idcounter: idcount});\r\n        }, START_TAG);\r\n        // end tag\r\n        lexer.rule(/<\\/([a-zA-Z][a-zA-Z-0-9]*)>/, (ctx, match) => {\r\n            ctx.accept(END_TAG, {name: match[1]});\r\n        }, END_TAG);\r\n        // placeholder\r\n        lexer.rule(/{{([0-9]+)}}/, (ctx, match) => {\r\n            ctx.accept(PLACEHOLDER, {idcounter: parseInt(match[1], 10)});\r\n        }, PLACEHOLDER);\r\n        // icu message ref\r\n        lexer.rule(/<ICU-Message-Ref_([0-9]+)\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE_REF, {idcounter: parseInt(match[1], 10)});\r\n        }, ICU_MESSAGE_REF);\r\n        // icu message\r\n        lexer.rule(/<ICU-Message\\/>/, (ctx, match) => {\r\n            ctx.accept(ICU_MESSAGE, {message: match[0]});\r\n        }, ICU_MESSAGE);\r\n        // text\r\n        lexer.rule(/./, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        lexer.rule(/[\\t\\r\\n]+/, (ctx, match) => {\r\n            plaintext += match[0];\r\n            ctx.ignore();\r\n        }, TEXT);\r\n        return lexer;\r\n    }\r\n\r\n    tokenize(normalizedMessage: string): Token[] {\r\n        const lexer: Tokenizr.default = this.getLexer();\r\n        lexer.reset();\r\n        lexer.input(normalizedMessage);\r\n        return lexer.tokens();\r\n    }\r\n\r\n}\r\n","import {ParsedMessage} from './parsed-message';\r\nimport {\r\n    EMPTY_TAG,\r\n    END_TAG, ICU_MESSAGE, ICU_MESSAGE_REF, ParsedMesageTokenizer, PLACEHOLDER, START_TAG, TEXT,\r\n    Token\r\n} from './parsed-message-tokenizer';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {DOMParser} from 'xmldom';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {IMessageParser} from './i-message-parser';\r\nimport {format, isNullOrUndefined} from 'util';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePartICUMessage} from './parsed-message-part-icu-message';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser can parse the xml content of a translatable message.\r\n * It generates a ParsedMessage from it.\r\n */\r\nexport abstract class AbstractMessageParser implements IMessageParser {\r\n\r\n    /**\r\n     * Parse XML to ParsedMessage.\r\n     * @param xmlElement the xml representation\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    public createNormalizedMessageFromXML(xmlElement: Element, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        if (xmlElement) {\r\n            message.setXmlRepresentation(xmlElement);\r\n            this.addPartsOfNodeToMessage(xmlElement, message, false);\r\n        }\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Parse XML string to ParsedMessage.\r\n     * @param xmlString the xml representation without root element, e.g. this is <ph x></ph> an example.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * Throws an error if normalized xml is not well formed.\r\n     */\r\n    createNormalizedMessageFromXMLString(xmlString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const doc: Document = new DOMParser().parseFromString('<dummy>' + xmlString + '</dummy>', 'text/xml');\r\n        const xmlElement: Element = <Element> doc.childNodes.item(0);\r\n        return this.createNormalizedMessageFromXML(xmlElement, sourceMessage);\r\n    }\r\n\r\n    /**\r\n     * recursively run through a node and add all identified parts to the message.\r\n     * @param node node\r\n     * @param message message to be generated.\r\n     * @param includeSelf if true, add node by itself, otherwise only children.\r\n     */\r\n    private addPartsOfNodeToMessage(node: Node, message: ParsedMessage, includeSelf: boolean) {\r\n        let processChildren = true;\r\n        if (includeSelf) {\r\n            if (node.nodeType === node.TEXT_NODE) {\r\n                message.addText(node.textContent);\r\n                return;\r\n            }\r\n            if (node.nodeType === node.ELEMENT_NODE) {\r\n                processChildren = this.processStartElement(<Element> node, message);\r\n            }\r\n        }\r\n        if (processChildren) {\r\n            const icuMessageText = this.getICUMessageText(node);\r\n            let isICU = !isNullOrUndefined(icuMessageText);\r\n            if (isICU) {\r\n                try {\r\n                    message.addICUMessage(icuMessageText);\r\n                } catch (error) {\r\n                    // if it is not parsable, handle it as non ICU\r\n                    console.log('non ICU message: ', icuMessageText, error);\r\n                    isICU = false;\r\n                }\r\n            }\r\n            if (!isICU) {\r\n                const children = node.childNodes;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    this.addPartsOfNodeToMessage(children.item(i), message, true);\r\n                }\r\n            }\r\n        }\r\n        if (node.nodeType === node.ELEMENT_NODE) {\r\n            this.processEndElement(<Element> node, message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    protected getICUMessageText(node: Node): string {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        const firstChild = children.item(0);\r\n        if (firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                return DOMUtilities.getXMLContent(<Element> node);\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether text is beginning of ICU Message.\r\n     * @param text text\r\n     */\r\n    public isICUMessageStart(text: string): boolean {\r\n        return ParsedMessagePartICUMessage.looksLikeICUMessage(text);\r\n//        return text.startsWith('{VAR_PLURAL') || text.startsWith('{VAR_SELECT');\r\n    }\r\n\r\n    /**\r\n     * Handle this node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected abstract processStartElement(elementNode: Element, message: ParsedMessage): boolean;\r\n\r\n    /**\r\n     * Handle end of this node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected abstract processEndElement(elementNode: Element, message: ParsedMessage);\r\n\r\n    /**\r\n     * Parse normalized string to ParsedMessage.\r\n     * @param normalizedString normalized string\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if normalized string is not well formed.\r\n     */\r\n    public parseNormalizedString(normalizedString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        const openTags = [];\r\n        let tokens: Token[];\r\n        try {\r\n            tokens = new ParsedMesageTokenizer().tokenize(normalizedString);\r\n        } catch (error) {\r\n            throw new Error(format('unexpected error while parsing message: \"%s\" (parsed \"%\")', error.message, normalizedString));\r\n        }\r\n        tokens.forEach((token: Token) => {\r\n            let disp: string = null;\r\n            switch (token.type) {\r\n                case TEXT:\r\n                    message.addText(token.value.text);\r\n                    break;\r\n                case START_TAG:\r\n                    message.addStartTag(token.value.name, token.value.idcounter);\r\n                    openTags.push(token.value.name);\r\n                    break;\r\n                case END_TAG:\r\n                    message.addEndTag(token.value.name);\r\n                    if (openTags.length === 0 || openTags[openTags.length - 1] !== token.value.name) {\r\n                        // oops, not well formed\r\n                        throw new Error(format('unexpected close tag \"%s\" (parsed \"%s\")', token.value.name, normalizedString));\r\n                    }\r\n                    openTags.pop();\r\n                    break;\r\n                case EMPTY_TAG:\r\n                    message.addEmptyTag(token.value.name, token.value.idcounter);\r\n                    break;\r\n                case PLACEHOLDER:\r\n                    disp = (sourceMessage) ? sourceMessage.getPlaceholderDisp(token.value.idcounter) : null;\r\n                    message.addPlaceholder(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE_REF:\r\n                    disp = (sourceMessage) ? sourceMessage.getICUMessageRefDisp(token.value.idcounter) : null;\r\n                    message.addICUMessageRef(token.value.idcounter, disp);\r\n                    break;\r\n                case ICU_MESSAGE:\r\n                    throw new Error(format('<ICUMessage/> not allowed here, use parseICUMessage instead (parsed \"%\")', normalizedString));\r\n                default:\r\n                    break;\r\n            }\r\n        });\r\n        if (openTags.length > 0) {\r\n            // oops, not well closed tags\r\n            throw new Error(format('missing close tag \"%s\" (parsed \"%s\")', openTags[openTags.length - 1], normalizedString));\r\n        }\r\n        message.setXmlRepresentation(this.createXmlRepresentation(message));\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Parse a string, that is an ICU message, to ParsedMessage.\r\n     * @param icuMessageString the message, like '{x, plural, =0 {nothing} =1 {one} other {many}}'.\r\n     * @param sourceMessage optional original message that will be translated by normalized new one\r\n     * @return a new parsed message.\r\n     * Throws an error if icuMessageString has not the correct syntax.\r\n     */\r\n    parseICUMessage(icuMessageString: string, sourceMessage: ParsedMessage): ParsedMessage {\r\n        const message: ParsedMessage = new ParsedMessage(this, sourceMessage);\r\n        message.addICUMessage(icuMessageString);\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Helper function: Parse ID from a name.\r\n     * name optionally ends with _<number>. This is the idcount.\r\n     * E.g. name=\"TAG_IMG\" returns 0\r\n     * name = \"TAG_IMG_1\" returns 1\r\n     * @param name name\r\n     * @return id count\r\n     */\r\n    protected parseIdCountFromName(name: string): number {\r\n        const regex = /.*_([0-9]*)/;\r\n        const match = regex.exec(name);\r\n        if (isNullOrUndefined(match) || match[1] === '') {\r\n            return 0;\r\n        } else {\r\n            const num = match[1];\r\n            return parseInt(num, 10);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the native xml for a message.\r\n     * Parts are already set here.\r\n     * @param message message\r\n     */\r\n    protected createXmlRepresentation(message: ParsedMessage): Element {\r\n        const root: Document = new DOMParser().parseFromString('<dummy/>', 'text/xml');\r\n        const rootElem: Element = root.getElementsByTagName('dummy').item(0);\r\n        this.addXmlRepresentationToRoot(message, rootElem);\r\n        return rootElem;\r\n    }\r\n\r\n    protected abstract addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element);\r\n\r\n    protected createXmlRepresentationOfTextPart(part: ParsedMessagePartText, rootElem: Element): Node {\r\n        return rootElem.ownerDocument.createTextNode(part.asDisplayString());\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected abstract createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node;\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected abstract createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id?: number): Node;\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected abstract createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node;\r\n}\r\n","/**\r\n * Created by roobm on 16.05.2017.\r\n * Mapping from normalized tag names to placeholder names.\r\n */\r\n\r\n/*\r\ncopied from https://github.com/angular/angular/blob/master/packages/compiler/src/i18n/serializers/placeholder.ts\r\n */\r\nconst TAG_TO_PLACEHOLDER_NAMES: {[k: string]: string} = {\r\n    'A': 'LINK',\r\n    'B': 'BOLD_TEXT',\r\n    'BR': 'LINE_BREAK',\r\n    'EM': 'EMPHASISED_TEXT',\r\n    'H1': 'HEADING_LEVEL1',\r\n    'H2': 'HEADING_LEVEL2',\r\n    'H3': 'HEADING_LEVEL3',\r\n    'H4': 'HEADING_LEVEL4',\r\n    'H5': 'HEADING_LEVEL5',\r\n    'H6': 'HEADING_LEVEL6',\r\n    'HR': 'HORIZONTAL_RULE',\r\n    'I': 'ITALIC_TEXT',\r\n    'LI': 'LIST_ITEM',\r\n    'LINK': 'MEDIA_LINK',\r\n    'OL': 'ORDERED_LIST',\r\n    'P': 'PARAGRAPH',\r\n    'Q': 'QUOTATION',\r\n    'S': 'STRIKETHROUGH_TEXT',\r\n    'SMALL': 'SMALL_TEXT',\r\n    'SUB': 'SUBSTRIPT',\r\n    'SUP': 'SUPERSCRIPT',\r\n    'TBODY': 'TABLE_BODY',\r\n    'TD': 'TABLE_CELL',\r\n    'TFOOT': 'TABLE_FOOTER',\r\n    'TH': 'TABLE_HEADER_CELL',\r\n    'THEAD': 'TABLE_HEADER',\r\n    'TR': 'TABLE_ROW',\r\n    'TT': 'MONOSPACED_TEXT',\r\n    'U': 'UNDERLINED_TEXT',\r\n    'UL': 'UNORDERED_LIST',\r\n};\r\n\r\n/**\r\n * HTML Tags (in uppercase) that are empty, they have no content, but do not need a close tag, e.g. <br>, <img>, <hr>.\r\n */\r\nconst VOID_TAGS = ['BR', 'HR', 'IMG', 'AREA', 'LINK', 'WBR'];\r\n\r\nexport class TagMapping {\r\n\r\n    public getStartTagPlaceholderName(tag: string, id: number): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `START_${baseName}` + this.counterString(id);\r\n    }\r\n\r\n    public getCloseTagPlaceholderName(tag: string): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return `CLOSE_${baseName}`;\r\n    }\r\n\r\n    public getEmptyTagPlaceholderName(tag: string, id: number): string {\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName =  TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        return baseName + this.counterString(id);\r\n    }\r\n\r\n    public getCtypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n                return 'lb';\r\n            case 'img':\r\n                return 'image';\r\n            default:\r\n                return `x-${tag}`;\r\n        }\r\n    }\r\n\r\n    public getTagnameFromStartTagPlaceholderName(placeholderName: string): string {\r\n        if (placeholderName.startsWith('START_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('START_TAG_'.length)).toLowerCase();\r\n        } else if (placeholderName.startsWith('START_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('START_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    public getTagnameFromCloseTagPlaceholderName(placeholderName: string): string {\r\n        if (placeholderName.startsWith('CLOSE_TAG_')) {\r\n            return this.stripCounter(placeholderName.substring('CLOSE_TAG_'.length)).toLowerCase();\r\n        } else if (placeholderName.startsWith('CLOSE_')) {\r\n            const ph = this.stripCounter(placeholderName.substring('CLOSE_'.length));\r\n            const matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n            return matchKey ? matchKey.toLowerCase() : null;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Test, wether placeholder name stands for empty html tag.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    public isEmptyTagPlaceholderName(placeholderName: string): boolean {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        } else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * tagname of empty tag placeholder.\r\n     * @param placeholderName can be TAG_<name> or just <name>\r\n     */\r\n    public getTagnameFromEmptyTagPlaceholderName(placeholderName: string): string {\r\n        const ph = this.stripCounter(placeholderName);\r\n        let matchKey;\r\n        if (ph.startsWith('TAG_')) {\r\n            matchKey = ph.substring(4).toUpperCase();\r\n        } else {\r\n            matchKey = Object.keys(TAG_TO_PLACEHOLDER_NAMES).find((key) => TAG_TO_PLACEHOLDER_NAMES[key] === ph);\r\n        }\r\n        if (matchKey) {\r\n            if (VOID_TAGS.indexOf(matchKey) >= 0) {\r\n                return matchKey.toLowerCase();\r\n            } else {\r\n                return null;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * If placeholder ends with _[0-9]+, strip that number.\r\n     * @param placeholderName placeholderName\r\n     * @return placeholderName without counter at end.\r\n     */\r\n    private stripCounter(placeholderName: string): string {\r\n        if (placeholderName) {\r\n            const re = /(.*)_[0-9]+$/;\r\n            if (placeholderName.match(re)) {\r\n                return placeholderName.replace(re, '$1');\r\n            }\r\n        }\r\n        return placeholderName;\r\n    }\r\n\r\n    /**\r\n     * String suffix for counter.\r\n     * If counter is 0, it is empty, otherwise _<id>.\r\n     * @param id id\r\n     * @return suffix for counter.\r\n     */\r\n    private counterString(id: number) {\r\n        if (id === 0) {\r\n            return '';\r\n        } else {\r\n            return '_' + id.toString(10);\r\n        }\r\n    }\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {isNullOrUndefined} from 'util';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 1.2\r\n */\r\nexport class XliffMessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        const tagMapping = new TagMapping();\r\n        if (tagName === 'x') {\r\n            // placeholder are like <x id=\"INTERPOLATION\"/> or <x id=\"INTERPOLATION_1\">\r\n            const id = elementNode.getAttribute('id');\r\n            if (!id) {\r\n                return; // should not happen\r\n            }\r\n            if (id.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromId(id);\r\n                message.addPlaceholder(index, null);\r\n            } else if (id.startsWith('ICU')) {\r\n                const index = this.parseICUMessageRefIndexFromId(id);\r\n                message.addICUMessageRef(index, null);\r\n            } else if (id.startsWith('START_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromStartTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addStartTag(normalizedTagName, idcount);\r\n                }\r\n            } else if (id.startsWith('CLOSE_')) {\r\n                const normalizedTagName = tagMapping.getTagnameFromCloseTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    message.addEndTag(normalizedTagName);\r\n                }\r\n            } else if (tagMapping.isEmptyTagPlaceholderName(id)) {\r\n                const normalizedTagName = tagMapping.getTagnameFromEmptyTagPlaceholderName(id);\r\n                if (normalizedTagName) {\r\n                    const idcount = this.parseIdCountFromName(id);\r\n                    message.addEmptyTag(normalizedTagName, idcount);\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return index\r\n     */\r\n    private parsePlaceholderIndexFromId(id: string): number {\r\n        let indexString = '';\r\n\r\n        if (id === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = id.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param id id\r\n     * @return id as number\r\n     */\r\n    private parseICUMessageRefIndexFromId(id: string): number {\r\n        let indexString = '';\r\n\r\n        if (id === 'ICU') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = id.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        message.parts().forEach((part) => {\r\n            let child: Node;\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    child = this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    child = this.createXmlRepresentationOfStartTagPart((<ParsedMessagePartStartTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    child = this.createXmlRepresentationOfEndTagPart((<ParsedMessagePartEndTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    child = this.createXmlRepresentationOfEmptyTagPart((<ParsedMessagePartEmptyTag>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    child = this.createXmlRepresentationOfPlaceholderPart((<ParsedMessagePartPlaceholder>part), rootElem);\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    child = this.createXmlRepresentationOfICUMessageRefPart((<ParsedMessagePartICUMessageRef>part), rootElem);\r\n                    break;\r\n            }\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        const ctypeAttrib = 'x-' + part.tagName();\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty <x/>-Element with attributes id and ctype\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        const tagMapping = new TagMapping();\r\n        const idAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        const ctypeAttrib = tagMapping.getCtypeForTag(part.tagName());\r\n        const equivTextAttr = '<' + part.tagName() + '/>';\r\n        xElem.setAttribute('id', idAttrib);\r\n        xElem.setAttribute('ctype', ctypeAttrib);\r\n        xElem.setAttribute('equiv-text', equivTextAttr);\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an empty <x/>-Element with attribute id=\"INTERPOLATION\" or id=\"INTERPOLATION_n\"\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        const equivTextAttr = part.disp();\r\n        xElem.setAttribute('id', idAttrib);\r\n        if (equivTextAttr) {\r\n            xElem.setAttribute('equiv-text', equivTextAttr);\r\n        }\r\n        return xElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const xElem = rootElem.ownerDocument.createElement('x');\r\n        let idAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            idAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        xElem.setAttribute('id', idAttrib);\r\n        return xElem;\r\n    }\r\n\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XliffMessageParser} from './xliff-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'util';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XLIFF 1.2 file.\r\n */\r\n\r\nexport class XliffTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            source = this._element.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XliffMessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new XliffMessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            return targetElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (targetElement) {\r\n            targetElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'new';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'new':\r\n                return STATE_NEW;\r\n            case 'needs-translation':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-adaptation':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-l10n':\r\n                return STATE_TRANSLATED;\r\n            case 'needs-review-translation':\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            case 'signed-off':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                const contextElements = elem.getElementsByTagName('context');\r\n                let sourcefile = null;\r\n                let linenumber = 0;\r\n                for (let j = 0; j < contextElements.length; j++) {\r\n                    const contextElem = contextElements.item(j);\r\n                    if (contextElem.getAttribute('context-type') === 'sourcefile') {\r\n                        sourcefile = DOMUtilities.getPCDATA(contextElem);\r\n                    }\r\n                    if (contextElem.getAttribute('context-type') === 'linenumber') {\r\n                        linenumber = Number.parseInt(DOMUtilities.getPCDATA(contextElem), 10);\r\n                    }\r\n                }\r\n                sourceRefs.push({sourcefile: sourcefile, linenumber: linenumber});\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        sourceRefs.forEach((ref) => {\r\n            const contextGroup = this._element.ownerDocument.createElement('context-group');\r\n            contextGroup.setAttribute('purpose', 'location');\r\n            const contextSource = this._element.ownerDocument.createElement('context');\r\n            contextSource.setAttribute('context-type', 'sourcefile');\r\n            contextSource.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile));\r\n            const contextLine = this._element.ownerDocument.createElement('context');\r\n            contextLine.setAttribute('context-type', 'linenumber');\r\n            contextLine.appendChild(this._element.ownerDocument.createTextNode(ref.linenumber.toString(10)));\r\n            contextGroup.appendChild(contextSource);\r\n            contextGroup.appendChild(contextLine);\r\n            this._element.appendChild(contextGroup);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('context-group');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            if (elem.getAttribute('purpose') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('description');\r\n        if (description) {\r\n           if (isNullOrUndefined(noteElem)) {\r\n               // create it\r\n               noteElem = this.createNoteElementWithFromAttribute('description', description);\r\n           } else {\r\n               DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n           }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithFromAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('from') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('from');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param fromAttrValue value of \"from\" attribute\r\n     * @param content text value of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithFromAttribute(fromAttrValue: string, content: string): Element {\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (fromAttrValue) {\r\n            noteElement.setAttribute('from', fromAttrValue);\r\n        }\r\n        noteElement.setAttribute('priority', '1');\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        this._element.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithFromAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithFromAttribute(attrValue);\r\n        if (noteElement) {\r\n            this._element.removeChild(noteElement);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            this._element.removeChild(noteElement);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff this is stored as a note element with attribute from=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param  meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        let noteElem = this.findNoteElementWithFromAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                noteElem = this.createNoteElementWithFromAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithFromAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('from'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n     }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * @throws an Error if any note contains description or meaning as from attribute.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                const noteElem = this.createNoteElementWithFromAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new XliffTransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = DOMUtilities.createFollowingSibling('target', source);\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        if (isDefaultLang) {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n        } else {\r\n            target.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n        }\r\n    }\r\n}\r\n","import { format } from 'util';\r\nimport { ITranslationMessagesFile } from '../api/i-translation-messages-file';\r\nimport { ITransUnit } from '../api/i-trans-unit';\r\nimport { FORMAT_XLIFF12, FILETYPE_XLIFF12 } from '../api/constants';\r\nimport { DOMUtilities } from './dom-utilities';\r\nimport { XliffTransUnit } from './xliff-trans-unit';\r\nimport { AbstractTranslationMessagesFile } from './abstract-translation-messages-file';\r\nimport { AbstractTransUnit } from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 23.02.2017.\r\n * Ab xliff file read from a source file.\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\n\r\nexport class XliffFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an xlf-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XliffFile\r\n     */\r\n    constructor(xmlString: string, path: string, encoding: string, optionalMaster?: { xmlContent: string, path: string, encoding: string }) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding, optionalMaster);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string, optionalMaster?: { xmlContent: string, path: string, encoding: string }): XliffFile {\r\n        this.parseContent(xmlString, path, encoding, optionalMaster);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        } else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '1.2';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 1.2 file, version should be %s, found %s',\r\n                    path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XLIFF12;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 1.2'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XLIFF12;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['source', 'target', 'tool', 'seg-source', 'g', 'ph', 'bpt', 'ept', 'it', 'sub', 'mrk'];\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('trans-unit');\r\n\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XliffTransUnit(transunit, id, this));\r\n        }\r\n\r\n        if (this._parsedOptionalMasterDocument) {\r\n            this.optionalMasterTransUnits = [];\r\n            // if we has an optional master document we push the optional master transunits to the array\r\n            const transUnitsInOptionalMasterFile = this._parsedOptionalMasterDocument.getElementsByTagName('trans-unit');\r\n            for (let i = 0; i < transUnitsInOptionalMasterFile.length; i++) {\r\n                const transunit = transUnitsInOptionalMasterFile.item(i);\r\n                const id = transunit.getAttribute('id');\r\n                if (!id) {\r\n                    this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n                }\r\n                this.optionalMasterTransUnits.push(new XliffTransUnit(transunit, id, this));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('source-language');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('source-language', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            return fileElem.getAttribute('target-language');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const fileElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (fileElem) {\r\n            fileElem.setAttribute('target-language', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = (<AbstractTransUnit>foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const bodyElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'body');\r\n        if (!bodyElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 1.2 file (should contain a body element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            bodyElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'trans-unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to body\r\n                bodyElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'trans-unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean, optionalMaster?: { xmlContent: string, path: string, encoding: string })\r\n        : ITranslationMessagesFile {\r\n\r\n        const translationFile = new XliffFile(this.editedContent(), filename, this.encoding(), optionalMaster);\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            (<AbstractTransUnit>transUnit).useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n\r\n        if (optionalMaster && translationFile.optionalMasterTransUnits && translationFile.optionalMasterTransUnits.length > 0) {\r\n            // If optional master is specified we will iterate the master transunits and remove from translation file if they already exist in the master\r\n            translationFile.optionalMasterTransUnits.forEach(unit => {\r\n                const tranUnit = translationFile.transUnitWithId(unit.id);\r\n                if (tranUnit) {\r\n                    translationFile.removeTransUnitWithId(tranUnit.id);\r\n                }\r\n            });\r\n        }\r\n\r\n        return translationFile;\r\n    }\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\nimport {ParsedMessagePart, ParsedMessagePartType} from './parsed-message-part';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XMB\r\n */\r\nexport class XmbMessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // There are 4 different usages of ph element:\r\n            // 1. placeholders are like <ph name=\"INTERPOLATION\"><ex>INTERPOLATION</ex></ph>\r\n            // or <ph name=\"INTERPOLATION_1\"><ex>INTERPOLATION_1</ex></ph>\r\n            // 2. start tags:\r\n            // <ph name=\"START_LINK\"><ex>&lt;a&gt;</ex></ph>\r\n            // 3. empty tags:\r\n            // <ph name=\"TAG_IMG\"><ex>&lt;img&gt;</ex></ph>\r\n            // 4. ICU:\r\n            // <ph name=\"ICU\"><ex>ICU</ex></ph>\r\n            const name = elementNode.getAttribute('name');\r\n            if (!name) {\r\n                return true; // should not happen\r\n            }\r\n            if (name.startsWith('INTERPOLATION')) {\r\n                const index = this.parsePlaceholderIndexFromName(name);\r\n                message.addPlaceholder(index, null);\r\n                return false; // ignore children\r\n            } else if (name.startsWith('START_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                if (tag) {\r\n                    message.addStartTag(tag, idcounter);\r\n                }\r\n                return false; // ignore children\r\n            } else if (name.startsWith('CLOSE_')) {\r\n                const tag = this.parseTagnameFromPhElement(elementNode);\r\n                if (tag) {\r\n                    message.addEndTag(tag);\r\n                }\r\n                return false; // ignore children\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(name)) {\r\n                const emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(name);\r\n                const idcounter = this.parseIdCountFromName(name);\r\n                message.addEmptyTag(emptyTagName, idcounter);\r\n                return false; // ignore children\r\n            } else if (name.startsWith('ICU')) {\r\n                const index = this.parseICUMessageIndexFromName(name);\r\n                message.addICUMessageRef(index, null);\r\n                return false; // ignore children\r\n            }\r\n        } else if (tagName === 'source') {\r\n            // ignore source\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Return the ICU message content of the node, if it is an ICU Message.\r\n     * @param node node\r\n     * @return message or null, if it is no ICU Message.\r\n     */\r\n    protected getICUMessageText(node: Node): string {\r\n        const children = node.childNodes;\r\n        if (children.length === 0) {\r\n            return null;\r\n        }\r\n        let firstChild = null;\r\n        // find first child that is no source element.\r\n        let i;\r\n        for (i = 0; i < children.length; i++) {\r\n            const child = children.item(i);\r\n            if (child.nodeType !== child.ELEMENT_NODE || (<Element> child).tagName !== 'source') {\r\n                firstChild = child;\r\n                break;\r\n            }\r\n        }\r\n        if (firstChild && firstChild.nodeType === firstChild.TEXT_NODE) {\r\n            if (this.isICUMessageStart(firstChild.textContent)) {\r\n                const messageText = DOMUtilities.getXMLContent(<Element> node);\r\n                if (i > 0) {\r\n                    // drop <source> elements\r\n                    const reSource: RegExp = new RegExp('<source[^>]*>.*</source>', 'g');\r\n                    return messageText.replace(reSource, '');\r\n                } else {\r\n                    return messageText;\r\n                }\r\n            } else {\r\n                return null;\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as placeholder index.\r\n     * id can be \"INTERPOLATION\" or \"INTERPOLATION_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    private parsePlaceholderIndexFromName(name: string): number {\r\n        let indexString = '';\r\n\r\n        if (name === 'INTERPOLATION') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = name.substring('INTERPOLATION_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse id attribute of x element as ICU message ref index.\r\n     * id can be \"ICU\" or \"ICU_n\"\r\n     * @param name name\r\n     * @return id as number\r\n     */\r\n    private parseICUMessageIndexFromName(name: string): number {\r\n        let indexString = '';\r\n\r\n        if (name === 'ICU') {\r\n            indexString = '0';\r\n        } else {\r\n            indexString = name.substring('ICU_'.length);\r\n        }\r\n        return Number.parseInt(indexString, 10);\r\n    }\r\n\r\n    /**\r\n     * Parse the tag name from a ph element.\r\n     * It contained in the <ex> subelements value and enclosed in <>.\r\n     * Example: <ph name=\"START_BOLD_TEXT\"><ex>&lt;b&gt;</ex></ph>\r\n     * @param phElement phElement\r\n     */\r\n    private parseTagnameFromPhElement(phElement: Element): string {\r\n        const exElement = DOMUtilities.getFirstElementByTagName(phElement, 'ex');\r\n        if (exElement) {\r\n            const value = DOMUtilities.getPCDATA(exElement);\r\n            if (!value || !value.startsWith('<') || !value.endsWith('>')) {\r\n                // oops\r\n                return null;\r\n            }\r\n            if (value.charAt(1) === '/') {\r\n                return value.substring(2, value.length - 1);\r\n            } else {\r\n                return value.substring(1, value.length - 1);\r\n            }\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        message.parts().forEach((part) => {\r\n            const child = this.createXmlRepresentationOfPart(part, rootElem);\r\n            if (child) {\r\n                rootElem.appendChild(child);\r\n            }\r\n        });\r\n    }\r\n\r\n    protected createXmlRepresentationOfPart(part: ParsedMessagePart, rootElem: Element): Node {\r\n        switch (part.type) {\r\n            case ParsedMessagePartType.TEXT:\r\n                return this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem);\r\n            case ParsedMessagePartType.START_TAG:\r\n                return this.createXmlRepresentationOfStartTagPart((<ParsedMessagePartStartTag>part), rootElem);\r\n            case ParsedMessagePartType.END_TAG:\r\n                return this.createXmlRepresentationOfEndTagPart((<ParsedMessagePartEndTag>part), rootElem);\r\n            case ParsedMessagePartType.EMPTY_TAG:\r\n                return this.createXmlRepresentationOfEmptyTagPart((<ParsedMessagePartEmptyTag>part), rootElem);\r\n            case ParsedMessagePartType.PLACEHOLDER:\r\n                return this.createXmlRepresentationOfPlaceholderPart((<ParsedMessagePartPlaceholder>part), rootElem);\r\n            case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                return this.createXmlRepresentationOfICUMessageRefPart((<ParsedMessagePartICUMessageRef>part), rootElem);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getStartTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getCloseTagPlaceholderName(part.tagName());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('</' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagMapping = new TagMapping();\r\n        const nameAttrib = tagMapping.getEmptyTagPlaceholderName(part.tagName(), part.idCounter());\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode('<' + part.tagName() + '>'));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns an <ph>-Element with attribute name and subelement ex\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let nameAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            nameAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('name', nameAttrib);\r\n        const exElem = rootElem.ownerDocument.createElement('ex');\r\n        exElem.appendChild(rootElem.ownerDocument.createTextNode(nameAttrib));\r\n        phElem.appendChild(exElem);\r\n        return phElem;\r\n    }\r\n}\r\n","import {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 01.05.2017.\r\n * A Translation Unit in an XMB file.\r\n */\r\n\r\nexport class XmbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and linenumber\r\n     */\r\n    private static parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: XmbTransUnit.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private static parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return source content\r\n     */\r\n    public sourceContent(): string {\r\n        let msgContent = DOMUtilities.getXMLContent(this._element);\r\n        const reSourceElem: RegExp = /<source>.*<\\/source>/g;\r\n        msgContent = msgContent.replace(reSourceElem, '');\r\n        return msgContent;\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // not supported\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, null);\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        // in fact, target and source are just the same in xmb\r\n        return this.sourceContent();\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return new XmbMessageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     */\r\n    public nativeTargetState(): string {\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // not supported for xmb\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            const sourceAndPos: string = DOMUtilities.getPCDATA(elem);\r\n            sourceRefs.push(XmbTransUnit.parseSourceAndPos(sourceAndPos));\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let insertPosition = this._element.childNodes.item(0);\r\n        for (let i = sourceRefs.length - 1; i >= 0; i--) {\r\n            const ref = sourceRefs[i];\r\n            const source = this._element.ownerDocument.createElement('source');\r\n            source.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            this._element.insertBefore(source, insertPosition);\r\n            insertPosition = source;\r\n        }\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const sourceElements = this._element.getElementsByTagName('source');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < sourceElements.length; i++) {\r\n            const elem = sourceElements.item(i);\r\n            toBeRemoved.push(elem);\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xmb this is stored in the attribute \"desc\".\r\n     */\r\n    public description(): string {\r\n        return this._element.getAttribute('desc');\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xmb this is stored in the attribute \"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        return this._element.getAttribute('meaning');\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xmb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * In fact, xmb cannot be translated.\r\n     * So this throws an error.\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        throw new Error('You cannot translate xmb files, use xtb instead.');\r\n    }\r\n\r\n}\r\n","import {ITranslationMessagesFileFactory} from '../api/i-translation-messages-file-factory';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XMB, FILETYPE_XMB, FORMAT_XTB} from '../api/constants';\r\nimport {format} from 'util';\r\nimport {XmbTransUnit} from './xmb-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\n\r\n/**\r\n * Created by martin on 10.03.2017.\r\n * xmb-File access.\r\n */\r\n\r\n/**\r\n * Doctype of xtb translation file corresponding with thos xmb file.\r\n */\r\nexport const XTB_DOCTYPE = `<!DOCTYPE translationbundle [\r\n  <!ELEMENT translationbundle (translation)*>\r\n  <!ATTLIST translationbundle lang CDATA #REQUIRED>\r\n  <!ELEMENT translation (#PCDATA|ph)*>\r\n  <!ATTLIST translation id CDATA #REQUIRED>\r\n  <!ELEMENT ph EMPTY>\r\n  <!ATTLIST ph name CDATA #REQUIRED>\r\n]>`;\r\n\r\nexport class XmbFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return XmbFile\r\n     */\r\n    constructor(\r\n        private _translationMessageFileFactory: ITranslationMessagesFileFactory,\r\n        xmlString: string, path: string, encoding: string) {\r\n\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string): XmbFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('messagebundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xmb file (should contain a messagebundle element)', path));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('msg');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new XmbTransUnit(msg, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XMB;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XMB'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XMB;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['message'];\r\n    }\r\n\r\n    /**\r\n     * Guess language from filename.\r\n     * If filename is foo.xy.xmb, than language is assumed to be xy.\r\n     * @return Language or null\r\n     */\r\n    private guessLanguageFromFilename(): string {\r\n        if (this._filename) {\r\n            const parts: string[] = this._filename.split('.');\r\n            if (parts.length > 2 && parts[parts.length - 1].toLowerCase() === 'xmb') {\r\n                return parts[parts.length - 2];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * Unsupported in xmb.\r\n     * Try to guess it from filename if any..\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        return this.guessLanguageFromFilename();\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * Unsupported in xmb.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        // do nothing, xmb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        throw Error('xmb file cannot be used to store translations, use xtb file');\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean, optionalMaster?: {xmlContent: string, path: string, encoding: string})\r\n        : ITranslationMessagesFile {\r\n        const translationbundleXMLSource =\r\n            '<?xml version=\"1.0\" encoding=\"UTF-8\"?>\\n' + XTB_DOCTYPE + '\\n<translationbundle>\\n</translationbundle>\\n';\r\n        const translationFile = this._translationMessageFileFactory.createFileFromFileContent(\r\n            FORMAT_XTB,\r\n            translationbundleXMLSource, filename, this.encoding(),\r\n            {xmlContent: this.editedContent(), path: this.filename(), encoding: this.encoding()});\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.setNewTransUnitTargetPraefix(this.getNewTransUnitTargetPraefix());\r\n        translationFile.setNewTransUnitTargetSuffix(this.getNewTransUnitTargetSuffix());\r\n        this.forEachTransUnit((tu) => {\r\n            translationFile.importNewTransUnit(tu, isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n\r\n}\r\n","import {AbstractMessageParser} from './abstract-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {ParsedMessagePartStartTag} from './parsed-message-part-start-tag';\r\nimport {ParsedMessagePartEndTag} from './parsed-message-part-end-tag';\r\nimport {ParsedMessagePartPlaceholder} from './parsed-message-part-placeholder';\r\nimport {ParsedMessagePartText} from './parsed-message-part-text';\r\nimport {ParsedMessagePartType} from './parsed-message-part';\r\nimport {TagMapping} from './tag-mapping';\r\nimport {ParsedMessagePartEmptyTag} from './parsed-message-part-empty-tag';\r\nimport {ParsedMessagePartICUMessageRef} from './parsed-message-part-icu-message-ref';\r\n/**\r\n * Created by roobm on 10.05.2017.\r\n * A message parser for XLIFF 2.0\r\n */\r\nexport class Xliff2MessageParser extends AbstractMessageParser {\r\n\r\n    /**\r\n     * Handle this element node.\r\n     * This is called before the children are done.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     * @return true, if children should be processed too, false otherwise (children ignored then)\r\n     */\r\n    protected processStartElement(elementNode: Element, message: ParsedMessage): boolean {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'ph') {\r\n            // placeholder are like <ph id=\"0\" equiv=\"INTERPOLATION\" disp=\"{{number()}}\"/>\r\n            // They contain the id and also a name (number in the example)\r\n            // TODO make some use of the name (but it is not available in XLIFF 1.2)\r\n            // ICU message are handled with the same tag\r\n            // Before 4.3.2 they did not have an equiv and disp (Bug #17344):\r\n            // e.g. <ph id=\"0\"/>\r\n            // Beginning with 4.3.2 they do have an equiv ICU and disp:\r\n            // e.g. <ph id=\"0\" equiv=\"ICU\" disp=\"{count, plural, =0 {...} =1 {...} other {...}}\"/>\r\n            // and empty tags have equiv other then INTERPOLATION:\r\n            // e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n            // or <ph equiv=\"LINE_BREAK\" type=\"lb\" disp=\"&lt;br/>\"/>\r\n            let isInterpolation = false;\r\n            let isICU = false;\r\n            let isEmptyTag = false;\r\n            const equiv = elementNode.getAttribute('equiv');\r\n            const disp = elementNode.getAttribute('disp');\r\n            let indexString = null;\r\n            let index = 0;\r\n            let emptyTagName = null;\r\n            if (!equiv) {\r\n                // old ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                indexString = elementNode.getAttribute('id');\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('ICU')) {\r\n                // new ICU syntax, fixed with #17344\r\n                isICU = true;\r\n                if (equiv === 'ICU') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('ICU_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (equiv.startsWith('INTERPOLATION')) {\r\n                isInterpolation = true;\r\n                if (equiv === 'INTERPOLATION') {\r\n                    indexString = '0';\r\n                } else {\r\n                    indexString = equiv.substring('INTERPOLATION_'.length);\r\n                }\r\n                index = Number.parseInt(indexString, 10);\r\n            } else if (new TagMapping().isEmptyTagPlaceholderName(equiv)) {\r\n                isEmptyTag = true;\r\n                emptyTagName = new TagMapping().getTagnameFromEmptyTagPlaceholderName(equiv);\r\n            } else {\r\n                return true;\r\n            }\r\n            if (isInterpolation) {\r\n                message.addPlaceholder(index, disp);\r\n            } else if (isICU) {\r\n                message.addICUMessageRef(index, disp);\r\n            } else if (isEmptyTag) {\r\n                message.addEmptyTag(emptyTagName, this.parseIdCountFromName(equiv));\r\n            }\r\n        } else if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addStartTag(embeddedTagName, this.parseIdCountFromName(elementNode.getAttribute('equivStart')));\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Handle end of this element node.\r\n     * This is called after all children are processed.\r\n     * @param elementNode elementNode\r\n     * @param message message to be altered\r\n     */\r\n    protected processEndElement(elementNode: Element, message: ParsedMessage) {\r\n        const tagName = elementNode.tagName;\r\n        if (tagName === 'pc') {\r\n            // pc example: <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\"\r\n            // dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">IMPORTANT</pc>\r\n            const embeddedTagName = this.tagNameFromPCElement(elementNode);\r\n            if (embeddedTagName) {\r\n                message.addEndTag(embeddedTagName);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n\r\n    private tagNameFromPCElement(pcNode: Element): string {\r\n        let dispStart = pcNode.getAttribute('dispStart');\r\n        if (dispStart.startsWith('<')) {\r\n            dispStart = dispStart.substring(1);\r\n        }\r\n        if (dispStart.endsWith('>')) {\r\n            dispStart = dispStart.substring(0, dispStart.length - 1);\r\n        }\r\n        return dispStart;\r\n    }\r\n\r\n    /**\r\n     * reimplemented here, because XLIFF 2.0 uses a deeper xml model.\r\n     * So we cannot simply replace the message parts by xml parts.\r\n     * @param message message\r\n     * @param rootElem rootElem\r\n     */\r\n    protected addXmlRepresentationToRoot(message: ParsedMessage, rootElem: Element) {\r\n        const stack = [{element: rootElem, tagName: 'root'}];\r\n        let id = 0;\r\n        message.parts().forEach((part) => {\r\n            switch (part.type) {\r\n                case ParsedMessagePartType.TEXT:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfTextPart(<ParsedMessagePartText> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.PLACEHOLDER:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfPlaceholderPart(<ParsedMessagePartPlaceholder> part, rootElem, id++));\r\n                    break;\r\n                case ParsedMessagePartType.ICU_MESSAGE_REF:\r\n                    stack[stack.length - 1].element.appendChild(\r\n                        this.createXmlRepresentationOfICUMessageRefPart(<ParsedMessagePartICUMessageRef> part, rootElem));\r\n                    break;\r\n                case ParsedMessagePartType.START_TAG:\r\n                    const newTagElem = this.createXmlRepresentationOfStartTagPart(<ParsedMessagePartStartTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(newTagElem);\r\n                    stack.push({element: <Element> newTagElem, tagName: (<ParsedMessagePartStartTag> part).tagName()});\r\n                    break;\r\n                case ParsedMessagePartType.END_TAG:\r\n                    const closeTagName = (<ParsedMessagePartEndTag> part).tagName();\r\n                    if (stack.length <= 1 || stack[stack.length - 1].tagName !== closeTagName) {\r\n                        // oops, not well formed\r\n                        throw new Error('unexpected close tag ' + closeTagName);\r\n                    }\r\n                    stack.pop();\r\n                    break;\r\n                case ParsedMessagePartType.EMPTY_TAG:\r\n                    const emptyTagElem = this.createXmlRepresentationOfEmptyTagPart(<ParsedMessagePartEmptyTag> part, rootElem, id++);\r\n                    stack[stack.length - 1].element.appendChild(emptyTagElem);\r\n                    break;\r\n            }\r\n        });\r\n        if (stack.length !== 1) {\r\n            // oops, not well closed tags\r\n            throw new Error('missing close tag ' + stack[stack.length - 1].tagName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for start tag in the message.\r\n     * Returns an empty pc-Element.\r\n     * e.g. <pc id=\"0\" equivStart=\"START_BOLD_TEXT\" equivEnd=\"CLOSE_BOLD_TEXT\" type=\"fmt\" dispStart=\"&lt;b&gt;\" dispEnd=\"&lt;/b&gt;\">\r\n     * Text content will be added later.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfStartTagPart(part: ParsedMessagePartStartTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const pcElem = rootElem.ownerDocument.createElement('pc');\r\n        const tagName = part.tagName();\r\n        const equivStart = tagMapping.getStartTagPlaceholderName(tagName, part.idCounter());\r\n        const equivEnd = tagMapping.getCloseTagPlaceholderName(tagName);\r\n        const dispStart = '<' + tagName + '>';\r\n        const dispEnd = '</' + tagName + '>';\r\n        pcElem.setAttribute('id', id.toString(10));\r\n        pcElem.setAttribute('equivStart', equivStart);\r\n        pcElem.setAttribute('equivEnd', equivEnd);\r\n        pcElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        pcElem.setAttribute('dispStart', dispStart);\r\n        pcElem.setAttribute('dispEnd', dispEnd);\r\n        return pcElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for end tag in the message.\r\n     * Not used here, because content is child of start tag.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfEndTagPart(part: ParsedMessagePartEndTag, rootElem: Element): Node {\r\n        // not used\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * the xml used for empty tag in the message.\r\n     * Returns an empty ph-Element.\r\n     * e.g. <ph id=\"3\" equiv=\"TAG_IMG\" type=\"image\" disp=\"&lt;img/>\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfEmptyTagPart(part: ParsedMessagePartEmptyTag, rootElem: Element, id: number): Node {\r\n        const tagMapping = new TagMapping();\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        const tagName = part.tagName();\r\n        const equiv = tagMapping.getEmptyTagPlaceholderName(tagName, part.idCounter());\r\n        const disp = '<' + tagName + '/>';\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equiv);\r\n        phElem.setAttribute('type', this.getTypeForTag(tagName));\r\n        phElem.setAttribute('disp', disp);\r\n        return phElem;\r\n    }\r\n\r\n    private getTypeForTag(tag: string): string {\r\n        switch (tag.toLowerCase()) {\r\n            case 'br':\r\n            case 'b':\r\n            case 'i':\r\n            case 'u':\r\n                return 'fmt';\r\n            case 'img':\r\n                return 'image';\r\n            case 'a':\r\n                return 'link';\r\n            default:\r\n                return 'other';\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the xml used for placeholder in the message.\r\n     * Returns e.g. <ph id=\"1\" equiv=\"INTERPOLATION_1\" disp=\"{{total()}}\"/>\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     * @param id id number in xliff2\r\n     */\r\n    protected createXmlRepresentationOfPlaceholderPart(part: ParsedMessagePartPlaceholder, rootElem: Element, id: number): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'INTERPOLATION';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'INTERPOLATION_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', id.toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n    /**\r\n     * the xml used for icu message refs in the message.\r\n     * @param part part\r\n     * @param rootElem rootElem\r\n     */\r\n    protected createXmlRepresentationOfICUMessageRefPart(part: ParsedMessagePartICUMessageRef, rootElem: Element): Node {\r\n        const phElem = rootElem.ownerDocument.createElement('ph');\r\n        let equivAttrib = 'ICU';\r\n        if (part.index() > 0) {\r\n            equivAttrib = 'ICU_' + part.index().toString(10);\r\n        }\r\n        phElem.setAttribute('id', part.index().toString(10));\r\n        phElem.setAttribute('equiv', equivAttrib);\r\n        const disp = part.disp();\r\n        if (disp) {\r\n            phElem.setAttribute('disp', disp);\r\n        }\r\n        return phElem;\r\n    }\r\n\r\n}\r\n","import {STATE_NEW, STATE_TRANSLATED, STATE_FINAL} from '../api/constants';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {Xliff2MessageParser} from './xliff2-message-parser';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\nimport {isNullOrUndefined} from 'util';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * A Translation Unit in an XLIFF 2.0 file.\r\n */\r\n\r\nexport class Xliff2TransUnit extends AbstractTransUnit  implements ITransUnit {\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile) {\r\n        super(_element, _id, _translationMessagesFile);\r\n    }\r\n\r\n    public sourceContent(): string {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        return DOMUtilities.getXMLContent(sourceElement);\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        let source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (!source) {\r\n            // should not happen, there always has to be a source, but who knows..\r\n            const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n            source = segment.parentNode.appendChild(this._element.ownerDocument.createElement('source'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(source, newContent);\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new Xliff2MessageParser();\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        const sourceElement = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        if (sourceElement) {\r\n            return this.messageParser().createNormalizedMessageFromXML(sourceElement, null);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return DOMUtilities.getXMLContent(targetElement);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        const targetElement = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        return new Xliff2MessageParser().createNormalizedMessageFromXML(targetElement, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation as stored in the xml.\r\n     */\r\n    public nativeTargetState(): string {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            return segmentElement.getAttribute('state');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        const segmentElement = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segmentElement) {\r\n            segmentElement.setAttribute('state', nativeState);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        switch ( state) {\r\n            case STATE_NEW:\r\n                return 'initial';\r\n            case STATE_TRANSLATED:\r\n                return 'translated';\r\n            case STATE_FINAL:\r\n                return 'final';\r\n            default:\r\n                throw new Error('unknown state ' +  state);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        switch ( nativeState) {\r\n            case 'initial':\r\n                return STATE_NEW;\r\n            case 'translated':\r\n                return STATE_TRANSLATED;\r\n            case 'reviewed': // same as translated\r\n                return STATE_TRANSLATED;\r\n            case 'final':\r\n                return STATE_FINAL;\r\n            default:\r\n                return STATE_NEW;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): {sourcefile: string, linenumber: number}[] {\r\n        // Source is found as <file>:<line> in <note category=\"location\">...\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const sourceRefs: { sourcefile: string, linenumber: number }[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === 'location') {\r\n                const sourceAndPos: string = DOMUtilities.getPCDATA(noteElem);\r\n                sourceRefs.push(this.parseSourceAndPos(sourceAndPos));\r\n            }\r\n        }\r\n        return sourceRefs;\r\n    }\r\n\r\n    /**\r\n     * Parses something like 'c:\\xxx:7' and returns source and linenumber.\r\n     * @param sourceAndPos something like 'c:\\xxx:7', last colon is the separator\r\n     * @return source and line number\r\n     */\r\n    private parseSourceAndPos(sourceAndPos: string): { sourcefile: string, linenumber } {\r\n        const index = sourceAndPos.lastIndexOf(':');\r\n        if (index < 0) {\r\n            return {\r\n                sourcefile: sourceAndPos,\r\n                linenumber: 0\r\n            };\r\n        } else {\r\n            return {\r\n                sourcefile: sourceAndPos.substring(0, index),\r\n                linenumber: this.parseLineNumber(sourceAndPos.substring(index + 1))\r\n            };\r\n        }\r\n    }\r\n\r\n    private parseLineNumber(lineNumberString: string): number {\r\n        return Number.parseInt(lineNumberString, 10);\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        this.removeAllSourceReferences();\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (sourceRefs.length === 0 && !isNullOrUndefined(notesElement) && notesElement.childNodes.length === 0) {\r\n            // remove empty notes element\r\n            notesElement.parentNode.removeChild(notesElement);\r\n            return;\r\n        }\r\n        if (isNullOrUndefined(notesElement)) {\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.insertBefore(notesElement, this._element.childNodes.item(0));\r\n        }\r\n        sourceRefs.forEach((ref) => {\r\n            const note = this._element.ownerDocument.createElement('note');\r\n            note.setAttribute('category', 'location');\r\n            note.appendChild(this._element.ownerDocument.createTextNode(ref.sourcefile + ':' + ref.linenumber.toString(10)));\r\n            notesElement.appendChild(note);\r\n        });\r\n    }\r\n\r\n    private removeAllSourceReferences() {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const toBeRemoved = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const elem = noteElements.item(i);\r\n            if (elem.getAttribute('category') === 'location') {\r\n                toBeRemoved.push(elem);\r\n            }\r\n        }\r\n        toBeRemoved.forEach((elem) => {elem.parentNode.removeChild(elem); });\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"description\".\r\n     */\r\n    public description(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('description');\r\n        if (description) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('description', description);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, description);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('description');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Find a note element with attribute category='<attrValue>'\r\n     * @param attrValue value of category attribute\r\n     * @return element or null is absent\r\n     */\r\n    private findNoteElementWithCategoryAttribute(attrValue: string): Element {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            if (noteElem.getAttribute('category') === attrValue) {\r\n                return noteElem;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all note elements where from attribute is not description or meaning\r\n     * @return elements\r\n     */\r\n    private findAllAdditionalNoteElements(): Element[] {\r\n        const noteElements = this._element.getElementsByTagName('note');\r\n        const result: Element[] = [];\r\n        for (let i = 0; i < noteElements.length; i++) {\r\n            const noteElem = noteElements.item(i);\r\n            const fromAttribute = noteElem.getAttribute('category');\r\n            if (fromAttribute !== 'description' && fromAttribute !== 'meaning') {\r\n                result.push(noteElem);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a new note element with attribute from='<attrValue>'\r\n     * @param attrValue category attribute value\r\n     * @param content content of note element\r\n     * @return the new created element\r\n     */\r\n    private createNoteElementWithCategoryAttribute(attrValue: string, content: string): Element {\r\n        let notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (isNullOrUndefined(notesElement)) {\r\n            // create it\r\n            notesElement = this._element.ownerDocument.createElement('notes');\r\n            this._element.appendChild(notesElement);\r\n        }\r\n        const noteElement = this._element.ownerDocument.createElement('note');\r\n        if (attrValue) {\r\n            noteElement.setAttribute('category', attrValue);\r\n        }\r\n        if (content) {\r\n            DOMUtilities.replaceContentWithXMLContent(noteElement, content);\r\n        }\r\n        notesElement.appendChild(noteElement);\r\n        return noteElement;\r\n    }\r\n\r\n    private removeNotesElementIfEmpty() {\r\n        const notesElement = DOMUtilities.getFirstElementByTagName(this._element, 'notes');\r\n        if (notesElement) {\r\n            const childNote = DOMUtilities.getFirstElementByTagName(this._element, 'note');\r\n            if (!childNote) {\r\n                // remove notes element\r\n                notesElement.parentNode.removeChild(notesElement);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove note element with attribute from='<attrValue>'\r\n     * @param attrValue attrValue\r\n     */\r\n    private removeNoteElementWithCategoryAttribute(attrValue: string) {\r\n        const noteElement = this.findNoteElementWithCategoryAttribute(attrValue);\r\n        if (noteElement) {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        }\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * Remove all note elements where attribute \"from\" is not description or meaning.\r\n     */\r\n    private removeAllAdditionalNoteElements() {\r\n        const noteElements = this.findAllAdditionalNoteElements();\r\n        noteElements.forEach((noteElement) => {\r\n            noteElement.parentNode.removeChild(noteElement);\r\n        });\r\n        this.removeNotesElementIfEmpty();\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xliff 2.0 this is stored as a note element with attribute category=\"meaning\".\r\n     */\r\n    public meaning(): string {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (noteElem) {\r\n            return DOMUtilities.getPCDATA(noteElem);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        const noteElem = this.findNoteElementWithCategoryAttribute('meaning');\r\n        if (meaning) {\r\n            if (isNullOrUndefined(noteElem)) {\r\n                // create it\r\n                this.createNoteElementWithCategoryAttribute('meaning', meaning);\r\n            } else {\r\n                DOMUtilities.replaceContentWithXMLContent(noteElem, meaning);\r\n            }\r\n        } else {\r\n            if (!isNullOrUndefined(noteElem)) {\r\n                // remove node\r\n                this.removeNoteElementWithCategoryAttribute('meaning');\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * Notes are remarks made by a translator.\r\n     * (description and meaning are not included here!)\r\n     */\r\n    public notes(): INote[] {\r\n        const noteElememts: Element[] = this.findAllAdditionalNoteElements();\r\n        return noteElememts.map(elem => {\r\n            return {\r\n                from: elem.getAttribute('category'),\r\n                text: DOMUtilities.getPCDATA(elem)\r\n            };\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            this.checkNotes(newNotes);\r\n        }\r\n        this.removeAllAdditionalNoteElements();\r\n        if (!isNullOrUndefined(newNotes)) {\r\n            newNotes.forEach((note) => {\r\n                this.createNoteElementWithCategoryAttribute(note.from, note.text);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, <string> translation);\r\n        this.setTargetState(STATE_TRANSLATED);\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        const element = <Element> this._element.cloneNode(true);\r\n        const clone = new Xliff2TransUnit(element, this._id, targetFile);\r\n        clone.useSourceAsTarget(isDefaultLang, copyContent);\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        const source = DOMUtilities.getFirstElementByTagName(this._element, 'source');\r\n        let target = DOMUtilities.getFirstElementByTagName(this._element, 'target');\r\n        if (!target) {\r\n            target = source.parentNode.appendChild(this._element.ownerDocument.createElement('target'));\r\n        }\r\n        if (isDefaultLang || copyContent) {\r\n            const sourceString = DOMUtilities.getXMLContent(source);\r\n            let newTargetString = sourceString;\r\n            if (!this.isICUMessage(sourceString)) {\r\n                newTargetString = this.translationMessagesFile().getNewTransUnitTargetPraefix()\r\n                    + sourceString\r\n                    + this.translationMessagesFile().getNewTransUnitTargetSuffix();\r\n            }\r\n            DOMUtilities.replaceContentWithXMLContent(target, newTargetString);\r\n        } else {\r\n            DOMUtilities.replaceContentWithXMLContent(target, '');\r\n        }\r\n        const segment = DOMUtilities.getFirstElementByTagName(this._element, 'segment');\r\n        if (segment) {\r\n            if (isDefaultLang) {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_FINAL));\r\n            } else {\r\n                segment.setAttribute('state', this.mapStateToNativeState(STATE_NEW));\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n","import {format} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XLIFF20, FILETYPE_XLIFF20} from '../api/constants';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {Xliff2TransUnit} from './xliff2-trans-unit';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 04.05.2017.\r\n * An XLIFF 2.0 file read from a source file.\r\n * Format definition is: http://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\r\n *\r\n * Defines some relevant get and set method for reading and modifying such a file.\r\n */\r\n\r\nexport class Xliff2File extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    /**\r\n     * Create an XLIFF 2.0-File from source.\r\n     * @param xmlString source read from file.\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @return xliff file\r\n     */\r\n    constructor(xmlString: string, path: string, encoding: string) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string): Xliff2File {\r\n        this.parseContent(xmlString, path, encoding);\r\n        const xliffList = this._parsedDocument.getElementsByTagName('xliff');\r\n        if (xliffList.length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff file (should contain an xliff element)', path));\r\n        } else {\r\n            const version = xliffList.item(0).getAttribute('version');\r\n            const expectedVersion = '2.0';\r\n            if (version !== expectedVersion) {\r\n                throw new Error(format('File \"%s\" seems to be no xliff 2 file, version should be %s, found %s',\r\n                    path, expectedVersion, version));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xmb', 'xmb2'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XLIFF20;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XLIFF 2.0'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XLIFF20;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['skeleton', 'note', 'data', 'source', 'target', 'pc', 'mrk'];\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('unit');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const transunit = transUnitsInFile.item(i);\r\n            const id = transunit.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, trans-unit without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            this.transUnits.push(new Xliff2TransUnit(transunit, id, this));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('srcLang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('srcLang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            return xliffElem.getAttribute('trgLang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const xliffElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'xliff');\r\n        if (xliffElem) {\r\n            xliffElem.setAttribute('trgLang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const fileElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'file');\r\n        if (!fileElement) {\r\n            throw new Error(format('File \"%s\" seems to be no xliff 2.0 file (should contain a file element)', this._filename));\r\n        }\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            fileElement.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstUnitElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'unit');\r\n            if (firstUnitElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstUnitElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to first file element\r\n                fileElement.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'unit', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean, optionalMaster?: {xmlContent: string, path: string, encoding: string})\r\n        : ITranslationMessagesFile {\r\n        const translationFile = new Xliff2File(this.editedContent(), filename, this.encoding());\r\n        translationFile.setNewTransUnitTargetPraefix(this.targetPraefix);\r\n        translationFile.setNewTransUnitTargetSuffix(this.targetSuffix);\r\n        translationFile.setTargetLanguage(lang);\r\n        translationFile.forEachTransUnit((transUnit: ITransUnit) => {\r\n            (<AbstractTransUnit> transUnit).useSourceAsTarget(isDefaultLang, copyContent);\r\n        });\r\n        return translationFile;\r\n    }\r\n}\r\n","import {isNullOrUndefined} from 'util';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {INormalizedMessage} from '../api/i-normalized-message';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {INote} from '../api/i-note';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\nimport {XmbMessageParser} from './xmb-message-parser';\r\nimport {ParsedMessage} from './parsed-message';\r\nimport {AbstractMessageParser} from './abstract-message-parser';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * A Translation Unit in an XTB file.\r\n */\r\n\r\nexport class XtbTransUnit extends AbstractTransUnit implements ITransUnit {\r\n\r\n    private _sourceTransUnitFromMaster: AbstractTransUnit;\r\n\r\n    constructor(_element: Element, _id: string, _translationMessagesFile: ITranslationMessagesFile,\r\n                _sourceTransUnitFromMaster: AbstractTransUnit) {\r\n        super(_element, _id, _translationMessagesFile);\r\n        this._sourceTransUnitFromMaster = _sourceTransUnitFromMaster;\r\n    }\r\n\r\n    /**\r\n     * Get content to translate.\r\n     * Source parts are excluded here.\r\n     * @return content to translate.\r\n     */\r\n    public sourceContent(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceContent();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source content is supported.\r\n     * If not, setSourceContent in trans-unit will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    supportsSetSourceContent(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set new source content in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing changed source content.\r\n     * @param newContent the new content.\r\n     */\r\n    public setSourceContent(newContent: string) {\r\n        // xtb has no source content, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * Return a parser used for normalized messages.\r\n     */\r\n    protected messageParser(): AbstractMessageParser {\r\n        return new XmbMessageParser(); // no typo!, Same as for Xmb\r\n    }\r\n\r\n    /**\r\n     * The original text value, that is to be translated, as normalized message.\r\n     */\r\n    public createSourceContentNormalized(): ParsedMessage {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.createSourceContentNormalized();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * the translated value (containing all markup, depends on the concrete format used).\r\n     */\r\n    public targetContent(): string {\r\n        return DOMUtilities.getXMLContent(this._element);\r\n    }\r\n\r\n    /**\r\n     * the translated value, but all placeholders are replaced with {{n}} (starting at 0)\r\n     * and all embedded html is replaced by direct html markup.\r\n     */\r\n    targetContentNormalized(): INormalizedMessage {\r\n        return this.messageParser().createNormalizedMessageFromXML(this._element, this.sourceContentNormalized());\r\n    }\r\n\r\n    /**\r\n     * State of the translation.\r\n     * (not supported in xmb)\r\n     * If we have a master, we assumed it is translated if the content is not the same as the masters one.\r\n     */\r\n    public nativeTargetState(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            const sourceContent = this._sourceTransUnitFromMaster.sourceContent();\r\n            if (!sourceContent || sourceContent === this.targetContent() || !this.targetContent()) {\r\n                return 'new';\r\n            } else {\r\n                return 'final';\r\n            }\r\n        }\r\n        return null; // not supported in xmb\r\n    }\r\n\r\n    /**\r\n     * Map an abstract state (new, translated, final) to a concrete state used in the xml.\r\n     * Returns the state to be used in the xml.\r\n     * @param state one of Constants.STATE...\r\n     * @returns a native state (depends on concrete format)\r\n     * @throws error, if state is invalid.\r\n     */\r\n    protected mapStateToNativeState(state: string): string {\r\n        return state;\r\n    }\r\n\r\n    /**\r\n     * Map a native state (found in the document) to an abstract state (new, translated, final).\r\n     * Returns the abstract state.\r\n     * @param nativeState nativeState\r\n     */\r\n    protected mapNativeStateToState(nativeState: string): string {\r\n        return nativeState;\r\n    }\r\n\r\n    /**\r\n     * set state in xml.\r\n     * (not supported in xmb)\r\n     * @param nativeState nativeState\r\n     */\r\n    protected setNativeTargetState(nativeState: string) {\r\n        // TODO some logic to store it anywhere\r\n    }\r\n\r\n    /**\r\n     * All the source elements in the trans unit.\r\n     * The source element is a reference to the original template.\r\n     * It contains the name of the template file and a line number with the position inside the template.\r\n     * It is just a help for translators to find the context for the translation.\r\n     * This is set when using Angular 4.0 or greater.\r\n     * Otherwise it just returns an empty array.\r\n     */\r\n    public sourceReferences(): { sourcefile: string, linenumber: number }[] {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.sourceReferences();\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of source refs is supported.\r\n     * If not, setSourceReferences will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetSourceReferences(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Set source ref elements in the transunit.\r\n     * Normally, this is done by ng-extract.\r\n     * Method only exists to allow xliffmerge to merge missing source refs.\r\n     * @param sourceRefs the sourcerefs to set. Old ones are removed.\r\n     */\r\n    public setSourceReferences(sourceRefs: {sourcefile: string, linenumber: number}[]) {\r\n        // xtb has no source refs, they are part of the master\r\n    }\r\n\r\n    /**\r\n     * The description set in the template as value of the i18n-attribute.\r\n     * e.g. i18n=\"mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public description(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.description();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The meaning (intent) set in the template as value of the i18n-attribute.\r\n     * This is the part in front of the | symbol.\r\n     * e.g. i18n=\"meaning|mydescription\".\r\n     * In xtb only the master stores it.\r\n     */\r\n    public meaning(): string {\r\n        if (this._sourceTransUnitFromMaster) {\r\n            return this._sourceTransUnitFromMaster.meaning();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of description and meaning is supported.\r\n     * If not, setDescription and setMeaning will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetDescriptionAndMeaning(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Change description property of trans-unit.\r\n     * @param description description\r\n     */\r\n    public setDescription(description: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Change meaning property of trans-unit.\r\n     * @param meaning meaning\r\n     */\r\n    public setMeaning(meaning: string) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Get all notes of the trans-unit.\r\n     * There are NO notes in xmb/xtb\r\n     */\r\n    public notes(): INote[] {\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Test, wether setting of notes is supported.\r\n     * If not, setNotes will do nothing.\r\n     * xtb does not support this, all other formats do.\r\n     */\r\n    public supportsSetNotes(): boolean {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Add notes to trans unit.\r\n     * @param newNotes the notes to add.\r\n     * NOT Supported in xmb/xtb\r\n     */\r\n    public setNotes(newNotes: INote[]) {\r\n        // not supported, do nothing\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * Returns a changed copy of this trans unit.\r\n     * receiver is not changed.\r\n     * (internal usage only, a client should call importNewTransUnit on ITranslationMessageFile)\r\n     * In xtb there is nothing to do, because there is only a target, no source.\r\n     */\r\n    public cloneWithSourceAsTarget(isDefaultLang: boolean, copyContent: boolean, targetFile: ITranslationMessagesFile): AbstractTransUnit {\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Copy source to target to use it as dummy translation.\r\n     * (internal usage only, a client should call createTranslationFileForLang on ITranslationMessageFile)\r\n     */\r\n    public useSourceAsTarget(isDefaultLang: boolean, copyContent: boolean) {\r\n        // do nothing\r\n    }\r\n\r\n    /**\r\n     * Set the translation to a given string (including markup).\r\n     * @param translation translation\r\n     */\r\n    protected translateNative(translation: string) {\r\n        const target = this._element;\r\n        if (isNullOrUndefined(translation)) {\r\n            translation = '';\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(target, translation);\r\n    }\r\n\r\n}\r\n","import {ITranslationMessagesFileFactory} from '../api/i-translation-messages-file-factory';\r\nimport {ITranslationMessagesFile} from '../api/i-translation-messages-file';\r\nimport {ITransUnit} from '../api/i-trans-unit';\r\nimport {FORMAT_XTB, FILETYPE_XTB, FORMAT_XMB} from '../api/constants';\r\nimport {format} from 'util';\r\nimport {DOMUtilities} from './dom-utilities';\r\nimport {AbstractTranslationMessagesFile} from './abstract-translation-messages-file';\r\nimport {XtbTransUnit} from './xtb-trans-unit';\r\nimport {AbstractTransUnit} from './abstract-trans-unit';\r\n/**\r\n * Created by martin on 23.05.2017.\r\n * xtb-File access.\r\n * xtb is the translated counterpart to xmb.\r\n */\r\n\r\nexport class XtbFile extends AbstractTranslationMessagesFile implements ITranslationMessagesFile {\r\n\r\n    // attached master file, if any\r\n    // used as source to determine state ...\r\n    private _masterFile: ITranslationMessagesFile; // an xmb-file\r\n\r\n    /**\r\n     * Create an xmb-File from source.\r\n     * @param _translationMessageFileFactory factory to create a translation file (xtb) for the xmb file\r\n     * @param xmlString file content\r\n     * @param path Path to file\r\n     * @param encoding optional encoding of the xml.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * @return XmbFile\r\n     */\r\n    constructor(private _translationMessageFileFactory: ITranslationMessagesFileFactory,\r\n                xmlString: string, path: string, encoding: string,\r\n                optionalMaster?: { xmlContent: string, path: string, encoding: string }) {\r\n        super();\r\n        this._warnings = [];\r\n        this._numberOfTransUnitsWithMissingId = 0;\r\n        this.initializeFromContent(xmlString, path, encoding, optionalMaster);\r\n    }\r\n\r\n    private initializeFromContent(xmlString: string, path: string, encoding: string,\r\n                                  optionalMaster?: { xmlContent: string, path: string, encoding: string }): XtbFile {\r\n        this.parseContent(xmlString, path, encoding);\r\n        if (this._parsedDocument.getElementsByTagName('translationbundle').length !== 1) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', path));\r\n        }\r\n        if (optionalMaster) {\r\n            try {\r\n                this._masterFile = this._translationMessageFileFactory.createFileFromFileContent(\r\n                    FORMAT_XMB,\r\n                    optionalMaster.xmlContent,\r\n                    optionalMaster.path,\r\n                    optionalMaster.encoding);\r\n                // check, wether this can be the master ...\r\n                const numberInMaster = this._masterFile.numberOfTransUnits();\r\n                const myNumber = this.numberOfTransUnits();\r\n                if (numberInMaster !== myNumber) {\r\n                    this._warnings.push(format(\r\n                        '%s trans units found in master, but this file has %s. Check if it is the correct master',\r\n                        numberInMaster, myNumber));\r\n                }\r\n            } catch (error) {\r\n                throw new Error(format('File \"%s\" seems to be no xmb file. An xtb file needs xmb as master file.', optionalMaster.path));\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected initializeTransUnits() {\r\n        this.transUnits = [];\r\n        const transUnitsInFile = this._parsedDocument.getElementsByTagName('translation');\r\n        for (let i = 0; i < transUnitsInFile.length; i++) {\r\n            const msg = transUnitsInFile.item(i);\r\n            const id = msg.getAttribute('id');\r\n            if (!id) {\r\n                this._warnings.push(format('oops, msg without \"id\" found in master, please check file %s', this._filename));\r\n            }\r\n            let masterUnit: ITransUnit = null;\r\n            if (this._masterFile) {\r\n                masterUnit = this._masterFile.transUnitWithId(id);\r\n            }\r\n            this.transUnits.push(new XtbTransUnit(msg, id, this, <AbstractTransUnit> masterUnit));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * File format as it is used in config files.\r\n     * Currently 'xlf', 'xlf2', 'xmb', 'xtb'\r\n     * Returns one of the constants FORMAT_..\r\n     */\r\n    public i18nFormat(): string {\r\n        return FORMAT_XTB;\r\n    }\r\n\r\n    /**\r\n     * File type.\r\n     * Here 'XTB'\r\n     */\r\n    public fileType(): string {\r\n        return FILETYPE_XTB;\r\n    }\r\n\r\n    /**\r\n     * return tag names of all elements that have mixed content.\r\n     * These elements will not be beautified.\r\n     * Typical candidates are source and target.\r\n     */\r\n    protected elementsWithMixedContent(): string[] {\r\n        return ['translation'];\r\n    }\r\n\r\n    /**\r\n     * Get source language.\r\n     * Unsupported in xmb/xtb.\r\n     * Try to guess it from master filename if any..\r\n     * @return source language.\r\n     */\r\n    public sourceLanguage(): string {\r\n        if (this._masterFile) {\r\n            return this._masterFile.sourceLanguage();\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the source language.\r\n     * Unsupported in xmb/xtb.\r\n     * @param language language\r\n     */\r\n    public setSourceLanguage(language: string) {\r\n        // do nothing, xtb has no notation for this.\r\n    }\r\n\r\n    /**\r\n     * Get target language.\r\n     * @return target language.\r\n     */\r\n    public targetLanguage(): string {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            return translationbundleElem.getAttribute('lang');\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Edit the target language.\r\n     * @param language language\r\n     */\r\n    public setTargetLanguage(language: string) {\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (translationbundleElem) {\r\n            translationbundleElem.setAttribute('lang', language);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new trans-unit to this file.\r\n     * The trans unit stems from another file.\r\n     * It copies the source content of the tu to the target content too,\r\n     * depending on the values of isDefaultLang and copyContent.\r\n     * So the source can be used as a dummy translation.\r\n     * (used by xliffmerge)\r\n     * @param foreignTransUnit the trans unit to be imported.\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     * @param importAfterElement optional (since 1.10) other transunit (part of this file), that should be used as ancestor.\r\n     * Newly imported trans unit is then inserted directly after this element.\r\n     * If not set or not part of this file, new unit will be imported at the end.\r\n     * If explicity set to null, new unit will be imported at the start.\r\n     * @return the newly imported trans unit (since version 1.7.0)\r\n     * @throws an error if trans-unit with same id already is in the file.\r\n     */\r\n    importNewTransUnit(foreignTransUnit: ITransUnit, isDefaultLang: boolean, copyContent: boolean, importAfterElement?: ITransUnit)\r\n        : ITransUnit {\r\n        if (this.transUnitWithId(foreignTransUnit.id)) {\r\n            throw new Error(format('tu with id %s already exists in file, cannot import it', foreignTransUnit.id));\r\n        }\r\n        const newMasterTu = (<AbstractTransUnit> foreignTransUnit).cloneWithSourceAsTarget(isDefaultLang, copyContent, this);\r\n        const translationbundleElem = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translationbundle');\r\n        if (!translationbundleElem) {\r\n            throw new Error(format('File \"%s\" seems to be no xtb file (should contain a translationbundle element)', this._filename));\r\n        }\r\n        const translationElement = translationbundleElem.ownerDocument.createElement('translation');\r\n        translationElement.setAttribute('id', foreignTransUnit.id);\r\n        let newContent = (copyContent || isDefaultLang) ? foreignTransUnit.sourceContent() : '';\r\n        if (!(<AbstractTransUnit> foreignTransUnit).isICUMessage(newContent)) {\r\n            newContent = this.getNewTransUnitTargetPraefix() + newContent + this.getNewTransUnitTargetSuffix();\r\n        }\r\n        DOMUtilities.replaceContentWithXMLContent(translationElement, newContent);\r\n        const newTu = new XtbTransUnit(translationElement, foreignTransUnit.id, this, newMasterTu);\r\n        let inserted = false;\r\n        let isAfterElementPartOfFile = false;\r\n        if (!!importAfterElement) {\r\n            const insertionPoint = this.transUnitWithId(importAfterElement.id);\r\n            if (!!insertionPoint) {\r\n                isAfterElementPartOfFile = true;\r\n            }\r\n        }\r\n        if (importAfterElement === undefined || (importAfterElement && !isAfterElementPartOfFile)) {\r\n            translationbundleElem.appendChild(newTu.asXmlElement());\r\n            inserted = true;\r\n        } else if (importAfterElement === null) {\r\n            const firstTranslationElement = DOMUtilities.getFirstElementByTagName(this._parsedDocument, 'translation');\r\n            if (firstTranslationElement) {\r\n                DOMUtilities.insertBefore(newTu.asXmlElement(), firstTranslationElement);\r\n                inserted = true;\r\n            } else {\r\n                // no trans-unit, empty file, so add to bundle at end\r\n                translationbundleElem.appendChild(newTu.asXmlElement());\r\n                inserted = true;\r\n            }\r\n        } else {\r\n            const refUnitElement = DOMUtilities.getElementByTagNameAndId(this._parsedDocument, 'translation', importAfterElement.id);\r\n            if (refUnitElement) {\r\n                DOMUtilities.insertAfter(newTu.asXmlElement(), refUnitElement);\r\n                inserted = true;\r\n            }\r\n        }\r\n        if (inserted) {\r\n            this.lazyInitializeTransUnits();\r\n            this.transUnits.push(newTu);\r\n            this.countNumbers();\r\n            return newTu;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new translation file for this file for a given language.\r\n     * Normally, this is just a copy of the original one.\r\n     * But for XMB the translation file has format 'XTB'.\r\n     * @param lang Language code\r\n     * @param filename expected filename to store file\r\n     * @param isDefaultLang Flag, wether file contains the default language.\r\n     * Then source and target are just equal.\r\n     * The content will be copied.\r\n     * State will be final.\r\n     * @param copyContent Flag, wether to copy content or leave it empty.\r\n     * Wben true, content will be copied from source.\r\n     * When false, content will be left empty (if it is not the default language).\r\n     */\r\n    public createTranslationFileForLang(lang: string, filename: string, isDefaultLang: boolean, copyContent: boolean, optionalMaster?: {xmlContent: string, path: string, encoding: string})\r\n        : ITranslationMessagesFile {\r\n        throw new Error(format('File \"%s\", xtb files are not translatable, they are already translations', filename));\r\n    }\r\n}\r\n","/**\r\n * Created by roobm on 21.03.2017.\r\n */\r\nimport {ITranslationMessagesFile} from './i-translation-messages-file';\r\nimport {XliffFile} from '../impl/xliff-file';\r\nimport {XmbFile} from '../impl/xmb-file';\r\nimport {format} from 'util';\r\nimport {Xliff2File} from '../impl/xliff2-file';\r\nimport {FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB} from './constants';\r\nimport {XtbFile} from '../impl/xtb-file';\r\nimport {ITranslationMessagesFileFactory} from './i-translation-messages-file-factory';\r\n\r\n/**\r\n * Helper class to read translation files depending on format.\r\n * This is part of the public api\r\n */\r\nexport class TranslationMessagesFileFactory implements ITranslationMessagesFileFactory {\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromFileContent(i18nFormat: string,\r\n                                  xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: string,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: string}): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromFileContent(i18nFormat, xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    public static fromUnknownFormatFileContent(xmlContent: string,\r\n                                  path: string,\r\n                                  encoding: string,\r\n                                  optionalMaster?: {xmlContent: string, path: string, encoding: string}): ITranslationMessagesFile {\r\n        return new TranslationMessagesFileFactory().createFileFromUnknownFormatFileContent(xmlContent, path, encoding, optionalMaster);\r\n    }\r\n\r\n    /**\r\n     * Read file function, result depends on format, either XliffFile or XmbFile.\r\n     * @param i18nFormat currently 'xlf' or 'xlf2' or 'xmb' or 'xtb' are supported\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromFileContent(i18nFormat: string,\r\n                              xmlContent: string,\r\n                              path: string,\r\n                              encoding: string,\r\n                              optionalMaster?: { xmlContent: string, path: string, encoding: string }): ITranslationMessagesFile {\r\n        if (i18nFormat === FORMAT_XLIFF12) {\r\n            return new XliffFile(xmlContent, path, encoding, optionalMaster);\r\n        }\r\n        if (i18nFormat === FORMAT_XLIFF20) {\r\n            return new Xliff2File(xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XMB) {\r\n            return new XmbFile(this, xmlContent, path, encoding);\r\n        }\r\n        if (i18nFormat === FORMAT_XTB) {\r\n            return new XtbFile(this, xmlContent, path, encoding, optionalMaster);\r\n        }\r\n        throw new Error(format('oops, unsupported format \"%s\"', i18nFormat));\r\n\r\n    }\r\n\r\n    /**\r\n     * Read file function for any file with unknown format.\r\n     * This functions tries to guess the format based on the filename and the content of the file.\r\n     * Result depends on detected format, either XliffFile or XmbFile.\r\n     * @param xmlContent the file content\r\n     * @param path the path of the file (only used to remember it)\r\n     * @param encoding utf-8, ... used to parse XML.\r\n     * This is read from the file, but if you know it before, you can avoid reading the file twice.\r\n     * @param optionalMaster in case of xmb the master file, that contains the original texts.\r\n     * (this is used to support state infos, that are based on comparing original with translated version)\r\n     * Ignored for other formats.\r\n     * @return either XliffFile or XmbFile\r\n     */\r\n    createFileFromUnknownFormatFileContent(xmlContent: string,\r\n                                           path: string,\r\n                                           encoding: string,\r\n                                           optionalMaster?: { xmlContent: string, path: string, encoding: string })\r\n        : ITranslationMessagesFile {\r\n        let formatCandidates = [FORMAT_XLIFF12, FORMAT_XLIFF20, FORMAT_XMB, FORMAT_XTB];\r\n        if (path && path.endsWith('xmb')) {\r\n            formatCandidates = [FORMAT_XMB, FORMAT_XTB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        if (path && path.endsWith('xtb')) {\r\n            formatCandidates = [FORMAT_XTB, FORMAT_XMB, FORMAT_XLIFF12, FORMAT_XLIFF20];\r\n        }\r\n        // try all candidate formats to get the right one\r\n        for (let i = 0; i < formatCandidates.length; i++) {\r\n            const formatCandidate = formatCandidates[i];\r\n            try {\r\n                const translationFile = TranslationMessagesFileFactory.fromFileContent(\r\n                    formatCandidate, xmlContent, path, encoding, optionalMaster);\r\n                if (translationFile) {\r\n                    return translationFile;\r\n                }\r\n            } catch (e) {\r\n                // seams to be the wrong format\r\n            }\r\n        }\r\n        throw new Error(format('could not identify file format, it is neiter XLIFF (1.2 or 2.0) nor XMB/XTB'));\r\n    }\r\n\r\n}\r\n\r\n"]}